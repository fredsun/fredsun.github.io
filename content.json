{"meta":{"title":"Hexo","subtitle":null,"description":"上进的懒狗","author":"FredSun","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-10-19T02:07:01.149Z","updated":"2017-10-19T02:07:01.149Z","comments":true,"path":"2017/10/19/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Day0","slug":"Day0-Android","date":"2017-09-30T16:00:00.000Z","updated":"2017-10-18T16:00:00.000Z","comments":true,"path":"2017/10/01/Day0-Android/","link":"","permalink":"http://yoursite.com/2017/10/01/Day0-Android/","excerpt":"","text":"版本号 Version Codename API Distribution 2.3.3 - 2.3.7 Gingerbread 10 0.7% 4.0.3 - 4.0.4 Ice Cream Sandwich 15 0.7% 4.1.x Jelly Bean 16 2.7% 4.2.x - 17 3.8% 4.3 - 18 1.1% 4.4 KitKat 19 16.0% 5.0 Lollipop 21 7.4% 5.1 22 21.8% 6.0 Marshmallow 23 32.3% 7.0 Nougat 24 12.3% 7.1 25 1.2% 获取版本号12345678910111213/** * 获取Android发布的版本 */ public static String getVersion() &#123; return android.os.Build.VERSION.RELEASE; &#125; /** * 获取SDK的API Level * @return */ public static int getSDK() &#123; return android.os.Build.VERSION.SDK_INT; &#125; 版本号适配TODO http://blog.csdn.net/haovip123/article/details/54618642 6.0的权限12345protected boolean hasPermission(String permission) &#123; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP_MR1) return (checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED); return true; &#125; 通知的副标题 API LEVEL16才能使用123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; builder.setSubText(&quot;it is really basic&quot;);&#125; 7.0 分屏多任务将 DecorView 从 PhoneWindow 中移出来, 并添加了 DecorCaptionView 作为分屏的实现 API Level建议写成版本名VERSION_CODES, 少用数字 UML图泛化(generalization)= is-a, 继承 实现(realize)= like-a, 实现 依赖(dependency)= 方法的形参, 局部变量, 对静态方法的调用 关联(association)= 成员变量 聚合(aggregation)= has-a, 不是强依赖, 如果整体不存在了, 个体还是存在的 组合(composition)= contains-a, 强依赖, 如果整体不存在了, 部分也不存在了 聚合和组合是关联关系的一种特例组合 &gt; 聚合 &gt; 关联 &gt; 依赖; 抽象类和接口抽象类是对根源的抽象, 接口是对动作的抽象抽象类是像xxx一样, 接口是能xxx这样抽象类可以有非抽象方法, 接口不行抽象类可以没有抽象方法, 接口不行抽象类可以有参数, 接口不行 内部类内部类只是 Java 的语法糖之一（在编译期做手脚）, 过了编译期后, 变生成两个 Java 文件内部类会持有外部类的引用匿名内部类是唯一没有构造器的类, 一般用于实现抽象类/接口 闭包From对象是带方法的数据, 而闭包是带(外部)数据的方法条件如下： 一个依赖于外部自由变量的函数 这个函数能够访问外围环境里的自由变量 关于组合子:内部操作依赖的变量全部由参数提供了的 “自给自足” 的函数f(x,y) = x+y 123public int add(int x, int y)&#123; return x+y;&#125; 关于自由变量: 在函数作用域以外，由函数的外部环境提供的参数就叫”自由变量（Free Variable）”f(x)=x+y 12345int y=3;add()&#123; int x=2; return x+y;&#125; 闭包: 就是把函数以及变量包起来，使得变量的生存周期延长。闭包跟面向对象是一棵树上的两条枝，实现的功能是等价的。所以java的类其实也是闭包 内部类是闭包(包含外部类的引用)如果局部内部类直接使用外部类的局部变量, 在Java多线程等情况下, 可能会产生外部类已被回收, 但是内部类还在运行, 那么内部类就可能会去访问一个不存在的外部类的局部变量.那么当局部变量被置为 final 时, 编译器会将 final 局部变量复制一份, 复制品直接作为局部内部中的数据成员, 这样, 当局部内部类访问变量时, 其实访问的是复制品. Java编译器实现的只是capture-by-value(包括lambda表达式)，并没有实现capture-by-reference 而且由于被 final 修饰的变量赋值后不能再修改, 所以就保证了复制品与原始变量的一致, 给人的感觉：好像局部变量的生命期延长了.这也是 Java的闭包. AndroidStudio 代码提示快捷键ClassNameCompletion win &amp; mac: Control + Shift + 空格键 和系统冲突, 建议keymap里修改. 参考Google | 信息中心简书 | Android-SDK版本号表格CSDN | 重新认识java（四） — 组合、聚合与继承的爱恨情仇CSDN | 看懂UML类图和时序图cnblogs | UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","categories":[],"tags":[]}]}