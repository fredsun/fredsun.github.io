{"meta":{"title":"花花世界","subtitle":"fred的blog","description":"上进的懒狗","author":"FredSun","url":"http://www.fredsun.me"},"pages":[{"title":"about","date":"2017-10-20T05:51:38.000Z","updated":"2017-10-20T05:58:12.507Z","comments":true,"path":"about/index.html","permalink":"http://www.fredsun.me/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-19T09:22:08.000Z","updated":"2017-10-20T06:09:31.970Z","comments":true,"path":"categories/index.html","permalink":"http://www.fredsun.me/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-19T08:48:51.000Z","updated":"2017-10-19T08:49:44.365Z","comments":true,"path":"tags/index.html","permalink":"http://www.fredsun.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Day37 - Gesture","slug":"Day37-TODO-Gesture","date":"2017-12-28T06:58:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day37-TODO-Gesture/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day37-TODO-Gesture/","excerpt":"未完待续多指触摸部分只完成了部分概念流程","text":"未完待续多指触摸部分只完成了部分概念流程 概念 MotionEvent 动作的事件 ID: 在整个手势映射期间一直存在, 用于追踪点 Index: 各个点的信息被存在数组, 点的索引值 Index 就是它在数组的位置. 大多数用来和点交互的 MotionEvent 函数都是以索引值Index, 而不是以ID作为参数的.(就是ID不变, Index很可能变) action: DOWN, UP, MOVE, CANCEL等动作 MotionEventCompat: 向下兼容的 MotionEvent, 随着谷歌放弃 2.2-api8, 该方法也被废弃 GestureDetectorCompat: 手势的监听. VelocityTracker: 追踪速度. 方法 处理手势, 在 onTouchEvent 中注册自己的 onTouchEvent 方法. 重写 onDown, onFling等. 创建 GestureDetectorCompat(Context, OnGestureListener)对象时, OnGestureListener 按照需求来注册, 默认的 Listener 方法过多, 不一定都能用得上.12342. ```VelocityTracker```: 处理速度, 在 ACTION_DOWN 时初始化, 然后在 ACTION_MOVE 时传入速度的时间单位, 记得在 ACTION_CANCEL 时清空 tracket.3. ```getActionMasked()```: 如果是单点,那和```getAction()```的返回值一样, 但是多点的时候, 举个例子[from](http://www.jianshu.com/p/0c863bbde8eb) （注:假设了int中不同位所代表的含义，可能不是例子中的前8位代表id,后8位代表事件类型） getAction() returns 0x0105. getActionMasked() will return 0x0005 其中0x0100就是pointer的index值。 ``` 一般来说， getAction() &amp; ACTION_POINTER_INDEX_MASK 就获得了pointer的id,等同于getActionId函数; getAction()&amp; ACTION_MASK 就获得了pointer的事件类型，等同于getActionMasked函数。流程 检测 检测触摸: onTouchEvent 中的 event 参数判断. 检测手势: GestureDetectorCompat 追踪 速度: VelocityTracker 滚动 TODO 处理多点 MotionEvent.getPointerCount()&gt;1, 就是多点 ACTION_DOWN, 第一个指头按下. ACTION_POINTER_DOWN, 第二个指头按下. ACTION_MOVE, 手指滑动 ACTION_POINTER_UP, 抬起了一个手指(还有别的手指在屏上) ACTION_UP, 最后一个手指抬了起来 拖拽 管理 QA Q: setOnTouchListener 和 onTouchEvent 的区别 A: setOnTouchListener 可以在不继承已有的 View 时拦截, 也可用于已知的 onTouchEvent 拦截钱","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Gesture","slug":"Gesture","permalink":"http://www.fredsun.me/tags/Gesture/"}]},{"title":"Day38 - GitCommitLog","slug":"Day38-GitCommitLog","date":"2017-12-28T06:57:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day38-GitCommitLog/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day38-GitCommitLog/","excerpt":"GitCommitLog规范","text":"GitCommitLog规范在使用Git 进行版本控制的时候，我们需要提交对应的 Commit 信息，这一块与 Changelog 的写作有一些类似，这一篇文章就介绍 Commit Message 的核心结构和规范。提交信息的结构一条 commit 信息通常包括3个部分：type: [标题] body footerType：类型具体来说，Type 分为： feat: 增加新功能； fix: 修复错误； docs: 修改文档； style: 修改样式； refactor: 代码重构； test: 增加测试模块，不涉及生产环境的代码； chore: 更新核心模块，包配置文件，不涉及生产环境的代码； Subject：标题 标题不超过50个字符，结尾不需要对应的句号；应该使用祈使句来描述，比如：修复标点符号错误。 Body：正文 并不是所有的 Commit 都需要正文，所以这一模块是可选的，必要的时候对本次 Commit 做一些背景说明，阐释具体的原因和内容，但是不解释具体的过程。注意：正文的文字不能超过72个字符。 Footer：结尾 结尾是可选的，通常来说可以添加对一些错误信息ID的补充。 Example：举例docs: add FAQ in readme file 作者：半撇链接：https://www.zhihu.com/question/21209619/answer/175414192来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Git","slug":"Git","permalink":"http://www.fredsun.me/tags/Git/"}]},{"title":"Day36 - Drawer","slug":"Day36-TODO-Drawer","date":"2017-12-28T06:53:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day36-TODO-Drawer/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day36-TODO-Drawer/","excerpt":"未完待续item的点击效果和分割线","text":"未完待续item的点击效果和分割线 item点击效果 group 添加checkableBehavior = single onNavigationItemSelected 返回true 也可直接item.setChecked(true); 分割线如果不需要分类标题. 直接用group套起来如果需要分类标题, 加item.就必须给item添加title了","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Drawer","slug":"Drawer","permalink":"http://www.fredsun.me/tags/Drawer/"}]},{"title":"Day35 - ProgressBar","slug":"Day35-TODO-ProgressBar","date":"2017-12-28T06:52:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day35-TODO-ProgressBar/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day35-TODO-ProgressBar/","excerpt":"未完待续设置横向ProgressBar, 修改progressbar样式","text":"未完待续设置横向ProgressBar, 修改progressbar样式 设置为横向style设置为 style=”?android:attr/progressBarStyleHorizontal” 修改样式设置progressDrawable/drawable 添加xml文件:123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@android:id/background\"&gt; &lt;shape&gt; &lt;!--&lt;corners android:radius=\"2dp\"&gt;&lt;/corners&gt;--&gt; &lt;gradient android:angle=\"270\" android:startColor=\"@color/colorShineWhite\" android:endColor=\"@color/colorShineWhite\"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:id=\"@android:id/progress\"&gt; &lt;clip&gt; &lt;shape&gt; &lt;!--&lt;corners android:radius=\"2dp\"/&gt;--&gt; &lt;gradient android:angle=\"270\" android:startColor=\"@color/colorAccent\" android:endColor=\"@color/colorAccent\"/&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt;&lt;/layer-list&gt;","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"ProgressBar","slug":"ProgressBar","permalink":"http://www.fredsun.me/tags/ProgressBar/"}]},{"title":"Day33 - Bitmap","slug":"Day33-TODO-Bitmap","date":"2017-12-28T06:50:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day33-TODO-Bitmap/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day33-TODO-Bitmap/","excerpt":"未完待续Bitmap压缩","text":"未完待续Bitmap压缩 获取Bitmap res转bitmap的最简方式: 1Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher); 弊端: 无论多大的图片直接解码, 如果图片过大容易OOM 优化: 参考 在不解码的情况下先获取bitmap大小. 保持原来比例的情况下缩放12345678910111213141516171819202122232425262728293031public static Bitmap getCompressedBitmap(String filePath, int requireWidth,int requireHeight) &#123; // inJustDecodeBounds 置为 true, 在不加载到内存时通过options获取参数 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; // 第一次解析 BitmapFactory.decodeFile(filePath, options); // 计算inSampleSize的值,并且赋值给Options.inSampleSize options.inSampleSize = calculateInSampleSize(options, requireWidth, requireHeight); // 使用获取到的inSampleSize再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options);&#125;private static int calculateInSampleSize(BitmapFactory.Options options, int requireWidth, int requireHeight) &#123; // 获取源图片的实际的宽度和高度 int realWidth = options.outWidth; int realHeight = options.outHeight; int inSampleSize = 1; if (realWidth &gt; requireWidth || realHeight &gt; requireHeight) &#123; // 计算出实际的宽高与目标宽高的比例 int widthRatio = Math.round((float) realWidth / (float) requireWidth); int heightRatio = Math.round((float) realHeight / (float) requireHeight); // 选择宽高比例最小的值赋值给inSampleSize,这样可以保证最终图片的宽高一定会大于或等于目标的宽高 inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; &#125; return inSampleSize;&#125;","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://www.fredsun.me/tags/Bitmap/"}]},{"title":"Day32 - Intent","slug":"Day32-TODO-Intent","date":"2017-12-28T06:47:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day32-TODO-Intent/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day32-TODO-Intent/","excerpt":"未完待续Intent匹配规则 &amp; 5.0后显式启动Service","text":"未完待续Intent匹配规则 &amp; 5.0后显式启动Service Intent 属性匹配规则 component: 举例 action: 隐式intent必须设置action. category: 需要完全匹配. data: 如果为注明, 则为content 或 file. mimeType. uri: ://:/[||] type extras Flags 查看有多少匹配的Intent Intent 开启三方应用时需要先用 resolveActivity() 方法判断, 如果要开启的应用不存在仍然强制开启, 可能为空. queryIntentActivities, 查看所有的成功匹配的Activity. 123if (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent);&#125; 启动service, 5.0后必须显式启动service 自定义Intent 可以setData和getData来传输Uri WebView无法通过redirect_uri, 回调起intent打开activity, 只能自己在WebViewClient的onPageFinished()里自己判断 webview中webviewclient的shouldOverrideUrlLoading. 是请求前过滤, 需要拦截则返回true参考","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Intent","slug":"Intent","permalink":"http://www.fredsun.me/tags/Intent/"}]},{"title":"Day34-自定义View","slug":"Day34-TODO-自定义view","date":"2017-12-27T16:03:00.000Z","updated":"2017-12-27T16:00:00.000Z","comments":true,"path":"2017/12/28/Day34-TODO-自定义view/","link":"","permalink":"http://www.fredsun.me/2017/12/28/Day34-TODO-自定义view/","excerpt":"未完待续","text":"未完待续 自定义view步骤: 获取xml里的设置的颜色，宽度等资源 初始化画笔paint 重写onDraw. canvas.drawXXX 进阶: 暴露方法, 通过postInvalidate()重绘. 重绘切记开子线程 自定义圆形进度条链接 TODO 自定义圆形图 链接自定义view 链接自定义view 链接","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://www.fredsun.me/tags/自定义View/"}]},{"title":"Day30 - Gradle","slug":"Day30-Gradle","date":"2017-12-13T16:03:00.000Z","updated":"2017-12-13T16:00:00.000Z","comments":true,"path":"2017/12/14/Day30-Gradle/","link":"","permalink":"http://www.fredsun.me/2017/12/14/Day30-Gradle/","excerpt":"Gradle配置BuildConfig","text":"Gradle配置BuildConfig tips: 以下栗子根据项目 org.tootto 说明 BuildConfig.java在tootto/app/build/generated/source/buildConfig/debug/org/tootto 下 有个BuildConfig.java123456789101112131415/** * Automatically generated file. DO NOT MODIFY */package org.tootto;public final class BuildConfig &#123; public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;); public static final String APPLICATION_ID = &quot;org.tootto&quot;; public static final String BUILD_TYPE = &quot;debug&quot;; public static final String FLAVOR = &quot;&quot;; public static final int VERSION_CODE = 1; public static final String VERSION_NAME = &quot;1.0&quot;; // Fields from build type: debug public static final String BUILD_TIME = &quot;0&quot;;&#125; 其中BUILD_TIME: 依靠tootto的gradle 中buildTypes下的buildConfigField 配置VERSION_NAME: = versionNameVERSION_CODE: = versionCode123456789101112131415161718192021android &#123; compileSdkVersion 27 defaultConfig &#123; applicationId &quot;org.tootto&quot; minSdkVersion 19 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; buildConfigField(&quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;0\\&quot;&quot;) resValue(&quot;string&quot;, &quot;build_time&quot;, &quot;0&quot;) &#125; &#125;&#125; 简书 | Gradle高级技巧","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://www.fredsun.me/tags/Gradle/"}]},{"title":"Day31 - http请求","slug":"Day31-TODO-http请求","date":"2017-12-13T16:03:00.000Z","updated":"2017-12-13T16:00:00.000Z","comments":true,"path":"2017/12/14/Day31-TODO-http请求/","link":"","permalink":"http://www.fredsun.me/2017/12/14/Day31-TODO-http请求/","excerpt":"base64和http请求的编码, OAuth验证等","text":"base64和http请求的编码, OAuth验证等 HTTP协议要求请求的首行和请求头都必须是ASCII编码, base64的意义 目的: 让数据符合传输协议的要求, 更便于传输. 而不是加密或数据校验 计算机中的任何数据都是以ascii码存储, 而ascii码的128-255的值是不可见字符. 在网络传输数据经过多个路由器时, 由于不同设备对字符的处理方式有一些不同, 这样不可见的可能被错误处理, 所以就先做Base64, 统统变成可见字符, 减少出错的可能性. 标准base64是 26*2 + 0-9 + “+” + “/“ 这样64个字符以及等号”=”. 等号一定用作后缀, 且数目一定是0,1,2个, 已知: 1个原始字符可以转化为1个ASCII码十进制值, 如 H = 72; e = 101; l = 108; 1个ASCII码十进制值可以转化成8个二进制值, 如 72 = 0100 1000; 每3个原始字符(也就是24个二进制值)在一起转成4个base64十进制值, 然后根据base64码表, 转换为base64编码后的字符. 如果不够三个字符就补上0, 如图的蓝色部分 对于转化后的结果SGVsbG8hIQAA, 因为AA不具备实际意义, 标准base64通常用”=”替代, 也就是SGVsbG8hIQ==. 所以不论如何, base64编码的字符串应该能被4整除, 如果不能, 先补充”=”.但是要记得在base64转换为二进制后, 要把补充为”=”的0扔掉. 最早是用在邮件传输协议, 邮件传输协议只支持ascii字符传递, 因此, 如果要传递图片. 视频则无法实现, 因此base64用来将文件编码为ascii 页面过多图片会导致请求过多, 直接文本存入html减少请求次数.参考文章参考知乎 服务器判断请求来源，通过user-agenttoken和session用户登陆理解:认证 + 交流 两种认证方式 basic auth. 每次请求传递密码, 没有安全 Oauth防止信息伪造, 包括重访攻击. Oauth2.0认证知乎两种交流方式 CookieAuth.Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；from只查询sessionID是否合法, 信任数据. token.认证信息通过http头传输时, 支持跨域访问. 比较:原生不支持cookie, 需要Cookie容器更基于JWT 如果这是访问自己的服务器, 自己的app, 用什么都无所谓. 如果数据需要和用户分享, 或者允许第三方调用API, 用Token. token是为了防止cookie被清除. httpclient也有cookieStore接口, 但是重启应用cookie就没了. cookie是所有域名请求都会带上, 有的请求可能不需要, 需要手动清除. session表示会话状态, 状态是存在服务器端的. 客户端只有session id, token 注重授权, 状态是存在客户端 token解码后会获取到全部信息. token随便改以为都提示无效 token放在header 参考几种常用的认证机制关于 Token，你应该知道的十件事","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"http","slug":"http","permalink":"http://www.fredsun.me/tags/http/"}]},{"title":"Day29 - kotlin","slug":"Day29-Kotlin","date":"2017-12-13T16:03:00.000Z","updated":"2017-12-13T16:00:00.000Z","comments":true,"path":"2017/12/14/Day29-Kotlin/","link":"","permalink":"http://www.fredsun.me/2017/12/14/Day29-Kotlin/","excerpt":"关于kotlin在tootto中的尝试","text":"关于kotlin在tootto中的尝试 正常项目转kotlin项目android studio 的 code -&gt; Convert Java FIle To Kotlin File提供了一键转换, 但是此时的编译失败, 需加如下插件和包 project.gradle 添加 12345678910111213141516buildscript &#123; ext.kotlin_version = &apos;1.1.51&apos; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; app.gradle添加 1234567891011121314apply plugin: &apos;com.android.application&apos;apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos;android &#123; ...&#125;dependencies &#123; ... implementation&quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;&#125; Kotlin file 转回Java file谷歌的深坑, 不如转过来方便 Tools -&gt; Kotlin -&gt; Show Kotlin ByteCode Decompile 复制. 粘贴, 修改文件后缀","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"kotlin","slug":"kotlin","permalink":"http://www.fredsun.me/tags/kotlin/"}]},{"title":"Day28 - find知乎CoordinatorLayout","slug":"Day28-find知乎CoordinatorLayout的实现","date":"2017-12-04T16:03:00.000Z","updated":"2017-12-05T16:00:00.000Z","comments":true,"path":"2017/12/05/Day28-find知乎CoordinatorLayout的实现/","link":"","permalink":"http://www.fredsun.me/2017/12/05/Day28-find知乎CoordinatorLayout的实现/","excerpt":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 仿知乎CoordinatorLayout的完整实现","text":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 仿知乎CoordinatorLayout的完整实现 tips:CoordinatorLayout(协调员布局)能实现一种类似协调视图之间改变效果的布局 文章分为三部分 CoordinatorLayout 概念的简介 仿写知乎自定义简单behavior.（非gif演示） 完整的拆包分析知乎和仿写知乎包括 MainActivity, 首页回答的 ListFragment, 和点击首页回答打开的回答详情的 DetailFragment. (gif演示的实现) 比较啰嗦, 建议阅读时间9分钟.可以直接跳到代码部分 Demo地址 「协调员」CoordinatorLayout「协调」概念 铺垫: 正常的事件分发传递, 如果某一层 View 消费掉了 Down事件. 之后的 MOVE, UP 事件都是传递到这一层, 无法直接实现子 view 和其他子 view的「协调」. 于是谷歌在15年的DesignSupportLibrary包 Revision 22.2.0 加入了 CoordinatorLayout. 作为「协调员」的核心外部控件 CoordinatorLayout: 是实现了 NestedScrollingParent 接口的 ViewGroup. 根据谷歌的描述, 它作为一个顶级布局, 同时作为子视图交互的容器 FrameLayout.那么它的子视图有哪些呢? 被依赖子View, 即可滚动的view, 实现 NestedScrollingChild 的子 view .(RecyclerView已实现) 依赖子View, 如 AppbarLayout(随着滑动的进行而跟着操作的view) 而依赖子view 依靠 behavior 控制. 谷歌对于behavior的描述是: CoordinatorLayout的子view的交互行为插件, 一个 behavior 可以实现一个或者多个交互 Behavior 里的方法分类1: view 监听另一个 view 的状态变化, 比如大小, 位置, 显示. layoutDependsOn 用来确定子View是否有另一个同级的View作为布局从属 onDependentViewChanged 响应被依赖子View的变化 分类2: view 监听 CoordinatorLayout 里的滑动状态 onStartNestedScroll 我们要不要关心, 要关心什么样的滑动 onNestedPreScroll 在嵌套滑动进行时，对象消费滚动距离前回调(使用的最频繁) 「协调」Demo-简单Behavior链接 下面我们开始仿造知乎的详情页来自定义一个 Behavior 知乎Behavior归纳1. MainActivity 里的 Listfragment(首页) 滑动一定距离就隐藏 触发效果后, 手不松, 在新的位置重置触发第1步所需的距离 和点击无关如果尝试过默认的behavior就会发现很像系统默认的 behavior. 123456789101112131415#### 2. 详情 DetailFragment1. 文件内容够长才开启滑动2. 刚进来时底view显示3. 快速滑动才显示/隐藏view4. 底view隐藏时, 单击显示/隐藏顶和底view.5. 下拉到底放出顶和底view.#### 3. MainActivity 的底部 TabLayout 再分析1. 如果极慢的滑动会发现, 对于同一个动画效果, 底部 TabLayout先于顶部 Toolbar 执行, 可以得出app第一页所看到的顶部和底部不是一个behavior控制的我们首先用behavior来写一个仿知乎的效果## Demo-自定义Behavior, 仿知乎布局1. 创建 CoordinatorLayout 布局 &lt;RecyclerView/&gt; &lt;LinearLayout app:layout_behavior=&quot;@string/my_behavior&quot; /&gt; 1&gt;如果一定要listview, 请判断版本 api21 后再setNestedScrollingEnabled if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { listView.setNestedScrollingEnabled(true); } 12345678910111213141516171819202122232425262728293031323334353637383940412. 自定义底部隐藏的动画 ```java public class MyBehaviorAnim &#123; private View mBottomView; private float mOriginalY; public BottomBehaviorAnim(View bottomView) &#123; mBottomView = bottomView; mOriginalY = mBottomView.getY(); &#125; public void show() &#123; ValueAnimator animator = ValueAnimator.ofFloat(mBottomView.getY(), mOriginalY); animator.setDuration(400); animator.setInterpolator(new LinearOutSlowInInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; mBottomView.setY((Float) valueAnimator.getAnimatedValue()); &#125; &#125;); animator.start(); &#125; public void hide() &#123; ValueAnimator animator = ValueAnimator.ofFloat(mBottomView.getY(), mOriginalY + mBottomView.getHeight()); animator.setDuration(400); animator.setInterpolator(new LinearOutSlowInInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; mBottomView.setY((Float) valueAnimator.getAnimatedValue()); &#125; &#125;); animator.start(); &#125; &#125; 自定义底部隐藏的Behavior 判断手势 计算距离 触发动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MyBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; protected BottomBehaviorAnim mBottomAnim; private boolean isHide; private boolean canScroll = true; private int mTotalScrollY; protected boolean isInit = true; //防止new Anim导致的parent 和child坐标变化 private int mDuration = 400; private Interpolator mInterpolator = new LinearOutSlowInInterpolator(); private int minScrollY = 5;//触发滑动动画最小距离 private int scrollYDistance = 40;//设置最小滑动距离 //1. 必须重写两个参数的构造方法, 因为behavior的实例化\b是反射这个构造方法实现的 public BottomBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; //2. 关心谁 @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return super.layoutDependsOn(parent, child, dependency); &#125; /** * 触发滑动嵌套滚动之前调用的方法 * * @param coordinatorLayout coordinatorLayout父布局 * @param child 使用Behavior的子View * @param target 触发滑动嵌套的View(实现NestedScrollingChild接口) * @param dx 滑动的X轴距离 * @param dy 滑动的Y轴距离 * @param consumed 父布局消费的滑动距离，consumed[0]和consumed[1]代表X和Y方向父布局消费的距离，默认为0 */ @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); &#125; /** * 滑动嵌套滚动时触发的方法 * * @param coordinatorLayout coordinatorLayout父布局 * @param child 使用Behavior的子View * @param target 触发滑动嵌套的View * @param dxConsumed TargetView消费的X轴距离 * @param dyConsumed TargetView消费的Y轴距离 * @param dxUnconsumed 未被TargetView消费的X轴距离 * @param dyUnconsumed 未被TargetView消费的Y轴距离(如RecyclerView已经到达顶部或底部，而用户继续滑动，此时dyUnconsumed的值不为0，可处理一些越界事件) */ @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (canScroll) &#123; mTotalScrollY += dyConsumed; if (Math.abs(dyConsumed) &gt; minScrollY || Math.abs(mTotalScrollY) &gt; scrollYDistance) &#123; if (dyConsumed &lt; 0) &#123; if (isHide) &#123; mBottomAnim.show(); isHide = false; &#125; &#125; else if (dyConsumed &gt; 0) &#123; if (!isHide) &#123; mBottomAnim.hide(); isHide = true; &#125; &#125; mTotalScrollY = 0; &#125; &#125; &#125; @Override public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int nestedScrollAxes) &#123; if (isInit) &#123; mBottomAnim = new BottomBehaviorAnim(child); isInit = false; &#125; return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0; &#125; @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, View child, final View target) &#123; super.onStopNestedScroll(coordinatorLayout, child, target); &#125;&#125; 关联xml和behavior先在 string 里添加 behavior, 再在依赖子 view 中添加 123&lt;resources&gt; &lt;string name=&quot;my_behavior&quot;&gt;com.clickdemo.Behavior.MyBehavior&lt;/string&gt;&lt;/resources&gt; 123&lt;LinearLayout app:layout_behavior=&quot;@string/my_behavior&quot; /&gt; 思考: 自定义behavior确实能做到类似知乎的隐藏 TabView 的效果, 但是知乎真的是这么实现的吗? Activity 和 Fragment 都用上了 CoordinatorLayout? 知乎知乎拆包静态分析. 准备 分析对象: 知乎的首页和回答详情页. 材料: 拆包拿到的xml等文件.（4.1.8包来源于酷安app端的历史版本） Luyten (查看.jar文件里的混淆后的java代码) Hierarchy View （AndroidStudio视图查看工具) 前提: 拆包拿到的activity_main.xml中可以看到, 底部的 com.zhihu.android.base.widget.ZHTabLayout 用到了 layout_behavior. 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;com.zhihu.android.app.ui.widget.ZHInsetsFrameLayout android:id=\"@id/content_container\" android:tag=\"layout/activity_main_0\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:zhihu=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;com.zhihu.android.app.ui.widget.reveal.widget.RevealFrameLayout android:background=\"?zhihu.background.window\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id=\"@id/coordinator_layout\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;com.zhihu.android.base.widget.NonSwipeableViewPager android:id=\"@id/main_pager\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" /&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" zhihu:layout_behavior=\"com.zhihu.android.base.widget.SnackBarBehavior\" zhihu:layout_anchorGravity=\"end|center|bottom\" /&gt; &lt;com.zhihu.android.base.widget.ZHTabLayout android:layout_gravity=\"end|bottom|center\" android:id=\"@id/main_tab\" android:background=\"?zhihu.background.navigation.tab.bottom\" android:layout_width=\"fill_parent\" android:layout_height=\"@dimen/bottom_navigation_height\" zhihu:layout_behavior=\"com.zhihu.android.base.widget.FooterBehavior\" zhihu:layout_anchorGravity=\"end|center|bottom\" zhihu:tabIndicatorColor=\"@android:color/transparent\" zhihu:tabGravity=\"fill\" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;/com.zhihu.android.app.ui.widget.reveal.widget.RevealFrameLayout&gt; &lt;com.zhihu.android.base.widget.ZHFrameLayout android:id=\"@id/overlay_container\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" /&lt;/com.zhihu.android.app.ui.widget.ZHInsetsFrameLayout&gt; 推测: MainActivity 包着四个Fragment, 底部依靠「tabLayout」切换, 然后进入详情页把内容都换一遍, 然后每一页一个 CoordinatorLayout? 目的: 查看知乎Fragment页的behavior如何实现的 拿到详情和首页Fragment的xml和java文件 用 Hierarchy View 拿到 view 的 id模拟器打开app, 进入首页的一个回答下, 用 Hierarchy View (在Android Studio自带的tool -&gt; Android Device Monitor) 发现是 CoordinatorLayout 包着 NonSwipeableViewPager + +ZHFrameLayout + ZHTabLayout , 之后进入详情页也是替换了 NonSwipeableViewPager 里的 FrameLayout.activity_main的效果如上图, 此时的FrameLayout显示的是首页ListFragment上图是FrameLayout显示的是回答详情DetailFragment 疑问1: 等等, 只有一个 CoordinatorLayout?之前猜的是有多个CoordinatorLayout啊? 常规使用下, CoordinatorLayout 的子view的子view，只能跟着上一级view整体实现协调, 即使AppBarLayout, 协调的效果也是固定的几种 所以知乎 Fragment 里底部的view和头部的toolbar是不依赖 CoordinatorLayout 进行协调的?还是先找到Activity和Fragment.java文件吧 根据 view 的 id 来找在哪些 xml 用到了它接下来我们用之前反编译好的资源开始寻找, 根据第1步, 我们看到了一个看似根布局的view, FrameInterceptLayout. 那就在res/layout里搜索下. 果然用到 FrameInterceptLayout 的地方不是很多. 而这 fragment_pager 和fragment_pager_2 看起来很可疑. 根据 xml 的 id 来找在哪些 java 文件里用到了它那接下来看下哪些地方用到了「fragment_pager」, 通过Android逆向之旅 可以得出: apk被反编译后会产生一个至关重要的 public.xml 文件, 就在res/values/public.xml下, 打开后搜一下, 哈, 找到你了, 面码, 0x7f0400be 和 0x7f0400bf.但是这是俩 十六进制 的东西啊. 对, Android逆向之旅里也告诉我们怎么看 0x7f0400be: 这里可以看到，一个id字段，都有对应的类型，名称，和id值的而这里的id值是一个整型值，8个字节；由三部分组成的：PackageId+TypeId+EntryIdPackageId：是包的Id值，Android中如果是第三方应用的话，这个值默认就是0x7F，系统应用的话就是0x01，具体我们可以后面看aapt源码得知，他占用两个字节。TypeId：是资源的类型Id值，一般Android中有这几个类型：attr，drawable，layout，dimen，string，style等，而且这些类型的值是从1开始逐渐递增的，而且顺序不能改变，attr=0x01，drawable=0x02….他占用两个字节。EntryId：是在具体的类型下资源实体的id值，从0开始，依次递增，他占用四个字节。 那就用计算器转换一下, 拿到十进制的 2130968766 和 2130968767 然后打开Luyten(替代JD_GUI, 有些文件JD_GUI打开后是一片空白). 打开一个jar文件, 先搜索一下 2130968766, 找到了. 看到databinding感叹下, 原来知乎早就上了databinding. 不过我们要的是下面这个com/zhihu/app/ui/fragment/b/i.class… 找到了这句话 1234public View a(final LayoutInflater layoutInflater, final ViewGroup viewGroup, final Bundle bundle) &#123; this.b = android.databinding.e.a(layoutInflater, 2130968766, viewGroup, false); return this.b.h();&#125; 可以猜到这句话就是 fragment 的 onCreateView 啦这就拿到了主页Fragment的java文件和xml文件了.同理拿到了 详情页的ZHObservableWebView, 首页列表的ZHRecyclerView extends ObservableRecyclerView. 这个频繁出现的ObservableXXXView 根据包名, 可以找到这个项目ksoichiro/Android-ObservableScrollView 当然了, 如果在第1步的HierarchyView里能找到特殊的id的view可以直接搜索, 比如详情页可以靠fragment_paging_layout搜到.详情页的view是fragment_paging.xml, 如下图 破案了! 结合疑问1, 可以得出:知乎的 Fragment 们的协调不是通过 CoordinatorLayout 的 behavior, 而是使用了观察者模式的开源项目. 总结一下(省略了过程): MainActivity 的底部 TabLayout 使用的是 CoordinatorLayout 的 layout_behavior 首页ListFragment 的顶部toolbar可能是 ZHObservableRecyclerView 也可能是 FrameInterceptLayout控制, xml文件是 fragment_paging, Java 文件在 首页详情DetailFragment 的顶部和底部是 ZHObservableWebView 控制 xml文件是 fragment_pager, Java 文件在com/zhihu/app/ui/fragment/b/i.class 为啥首页详情页这么肯定是 ZHObservableWebView 控制的呢, 因为在Luyten里查看到的知乎源码中重写了onScrollChange 方法, 多返回了int l, t, oldl, oldt 四个参数, 而我自己在写的时候发现也需要这四个参数才方便实现结果. 大致效果如图: 具体Demo 地址核心部分原理描述:从 MainActivity 的 ListFragment 切换到 DetailFragment 时, 把 ListFragment 的 toolbar 和 MainActivity 的 tabLayout 恢复原样(先GONE掉).从 DetailFragment 切换回 ListFragment 时, 直接VISIBLE 底部tabLayout. 弯路 如何只在快速下滑时才触发 behavior 的 onNestedScroll(仿知乎详情页) 原思路: 通过event监听手势Y轴速度. 传给behavior. 又因为「协调」时 onTouchEvent 无法接收到事件, behavior不属于ViewGroup, 无法在 behavior 里调用 dispatchTouchEvent, 只能在Activity里调, 所以采用 activity 监听的dispatchTouchEvent里event的 Y 轴速度, 再回调给behavior. 现思路: 其实 onNestedScroll 的参数 dyConsumed (Y 轴偏移量的大小)就是速度… 如何判断滑到底 原思路: 在 「协调」监听 onNestedScroll 里, dyConsumed == 0 时表示滑到边界了, dyUnconsumed &gt; 0 表示滑到边界了还在下拉, 所以通过(dyConsumed == 0 &amp;&amp; dyUnconsumed &gt; 0)来判断 现思路: boolean view.canScrollVertically(1) 的返回值表示能够下拉, -1的返回值表示上拉 详情Fragment覆盖了本该在前面的TabLayout, 即如何让xml中被TabLayout挡住的ViewPager, 反过来挡住 TabLayout. 原思路: 看到源代码中 afollestad/material-dialogs, 误以为新开的Fragment都是 DialogFragment 原思路: 通过 View.bringToFront 现思路: DialogFragment 在Hierarchy View里能看到多开了一个 MainActivity 进程. 里面重新从 DecorView 开始的布局, View.bringToFront 即使不开启新的 DecorView, 也改变了原进程, 无法在Hierarchy View上与知乎的布局一样. 为啥不直接使用 dispatchTouchEvent behavior 里没有重写 dispatchTouchEvent 为啥不 onTouchEvent behavior 里在拿到一段ACTION_MOVE后会拦截掉直接扔给 Behavior 一个 ACTION_CANCEL 参考 app:layout_scrollFlags效果 自定义behavior入门 借鉴仿知乎behavior库 LBehavior的动画效果 源码看CoordinatorLayout.Behavior原理","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"CoordinatorLayout","slug":"CoordinatorLayout","permalink":"http://www.fredsun.me/tags/CoordinatorLayout/"}]},{"title":"Day27 - 回调","slug":"Day27-Java回调","date":"2017-11-07T02:15:00.000Z","updated":"2017-11-06T16:00:00.000Z","comments":true,"path":"2017/11/07/Day27-Java回调/","link":"","permalink":"http://www.fredsun.me/2017/11/07/Day27-Java回调/","excerpt":"回调的简单demo","text":"回调的简单demo 简述A类让”有能力”的B类去完成某些事情, A类只负责命令, B类负责具体实施. 实现 需要返回值的类创建接口 1234567891011121314151617181920public class A&#123; //1. 创建接口 public interface Callback&#123; boolean doSomething(); &#125; //2. 创建接口实例 private Callback mCallback; //3. 给接口实例赋值的方法 //注意: 这句set只会被调用一次, 之后的mCallback都不走这, 所以在这获取值没用 public void setCallback(Callback callback)&#123; this.mCallback = callback; &#125; //4. 正常使用接口的回调值的地方 public void execute()&#123; Log.i(tag, mCallback.doSomething()+&quot;&quot;); &#125;&#125; 返回数值的类.创建需要值的类, 并实现接口, 重写接口方法. 1234567891011121314151617181920public class B extends AppCompatActivity implements A.Callback &#123; //1. 创建A的实例 private A mA; //2. 实现A里的接口 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... A mA = new A(); //3. B发起回调, 通过A的实例 mA.setCallback(this); &#125; //4. 实现接口 &amp; 重写方法 @Override public boolean doSomething() &#123; return false; &#125;&#125; 参考对Android中“回调”的理解","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.fredsun.me/tags/Java/"}]},{"title":"","slug":"Day28-RecyclerView","date":"2017-10-31T02:33:48.468Z","updated":"2017-10-31T05:50:49.632Z","comments":true,"path":"2017/10/31/Day28-RecyclerView/","link":"","permalink":"http://www.fredsun.me/2017/10/31/Day28-RecyclerView/","excerpt":"","text":"基本流程 app 中 build.gradle 添加 compile ‘com.android.support:design:27.0.0’ 布局中添加RecyclerView 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/my_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.clickdemo.MainActivity&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/lv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/top_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;30dp&quot; android:layout_gravity=&quot;top&quot; android:background=&quot;@color/colorAccent&quot; android:text=&quot;top&quot; /&gt; &lt;TextView android:id=&quot;@+id/btm_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;30dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;@color/colorAccent&quot; android:text=&quot;bottom&quot; /&gt;&lt;/FrameLayout&gt; 创建item布局 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot;/&gt;&lt;/FrameLayout&gt; 封装 Adapter 先创建类继承 RecyclerView.Adapter&lt;&gt;, 然后在写完自定义内部类ViewHolder后, 再补全&lt;&gt;里的内容, 重写onCreateViewHolder, onBindViewHolder. 123456789101112131415161718192021222324252627282930313233343536373839404142//2. 再把 DemoAdapter.ViewHolder 填进 RecyclerView.Adapter&lt;&gt;public class DemoAdapter extends RecyclerView.Adapter&lt;DemoAdapter.ViewHolder&gt; &#123; private ArrayList&lt;String&gt; datas; public DemoAdapter(ArrayList&lt;String&gt; datas) &#123; this.datas = datas; &#125; //3. 最后再重写onCreateViewHolder 和 onBindViewHolder 方法 @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_main, parent, false); final ViewHolder holder = new ViewHolder(view); holder.itemText.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(view.getContext(), &quot;you click text&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.itemText.setText(datas.get(position)); &#125; @Override public int getItemCount() &#123; return datas.size(); &#125; //1. 先写viewHolder static class ViewHolder extends RecyclerView.ViewHolder&#123; TextView itemText; public ViewHolder(View itemView) &#123; super(itemView); itemText = itemView.findViewById(R.id.tv_item); &#125; &#125;&#125; activity中调用 12345678910111213141516171819202122232425262728293031@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final ArrayList list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); list.add(&quot;g&quot;); list.add(&quot;h&quot;); list.add(&quot;i&quot;); list.add(&quot;j&quot;); list.add(&quot;k&quot;); list.add(&quot;l&quot;); list.add(&quot;m&quot;); list.add(&quot;n&quot;); list.add(&quot;o&quot;); list.add(&quot;p&quot;); list.add(&quot;q&quot;); DemoAdapter demoAdapter = new DemoAdapter(list); LinearLayoutManager layoutManager = new LinearLayoutManager(this); RecyclerView recyclerView = findViewById(R.id.lv); recyclerView.setAdapter(demoAdapter); recyclerView.setLayoutManager(layoutManager);&#125;","categories":[],"tags":[]},{"title":"Day26 - Git","slug":"Day26-Git","date":"2017-10-27T02:35:00.000Z","updated":"2017-11-15T16:00:00.000Z","comments":true,"path":"2017/10/27/Day26-Git/","link":"","permalink":"http://www.fredsun.me/2017/10/27/Day26-Git/","excerpt":"建远程库时最好有 README .md, 别空空荡荡的","text":"建远程库时最好有 README .md, 别空空荡荡的 区别其他版本控制git 分为工作区, 版本库的暂存区和版本库的分支git 操作的是文件的修改, 而不是文件. 我们在工作区修改过的文件 add 后进入暂存区, 再接着第二次修改后, 如果不 add, 直接 commit, 提交到分支里的是暂存区里的第一次修改 HTTPS 和 SSHTODO ###1. 建库123cd [localUrl] 进入本地目录git init 初始化gitgit remote add origin [remoteUrl] 关联远程仓库, origin 是远程库的默认代称. ###2. 拉取123git pull origin master 拉取master分支里的仓库. master是默认主分支名称或者git clones [remoteUrl] 直接拉取全部仓库到本地 ###3. 提交1234git add xxxgit commit -m &quot;提交信息&quot;git push -u origin master 将本地的master分支推送到origin主机, 同时指定origin为默认主机之后的提交不用-u, 直接 git push origin master就行 ###4. 后悔药-版本12345git log 查看详细提交信息,版本号等git log --pretty=oneline 查看精简提交信息, 只有版本号和提交描述git reset --hard HEAD^ 回退上一个版本, HEAD^^回退上上个版本, HEAD~100往上100个版本git reset xxxxxx 穿越到指定版本, 版本号还不必写全, git会自行查找, 但也不能太短git reflog 再次打开terminal时查看之前用过的命令 ###5. 查看工作区1git status 查看工作区哪些文件修改了, 修改的记得add. ###6. 后悔药-操作123git checkout -- file 撤销修改.一定要加--, 不然checkout是在切换分支.cheout的结果: 1.只是修改, 回到修改前. 2.add进暂存区后又改了文件, 回到修改前也就是add后的git reset file 撤销add. ###7. 删除12git rm filegit commit -m &quot;删除描述&quot; ###8. 分支12345678910git checkout -b dev 创建并选择分支== git checkout dev + git branch dev.git branch 查看所有分支git branch dev 创建dev分支git checkout dev 选择dev分支在dev分支操作一同后, 开始合并git merge dev dev合并进mastergit branch -d dev 删掉dev, 强行删除把 D 大写git log --graph 查看分支合并图git merge --no-ff -m &quot;保留分支信息的合并描述&quot; dev 以后能看出这里做过合并 ###9. 临时保存现场123456git stash 保存现场git stash pop 恢复现场.并删除stash或git stash apply 恢复现场, 删除需要自己 git stash dropgit stash list 查看stash列表git stash apply stash@&#123;0&#125; 恢复指定stash ###10. 给提交打 tag123456git tag v1.0 打tag, 默认给最新的commitgit tag vx 622222 给指定commit 打taggit tag 查看taggit tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用 -a 指定 tag 创建说明文字 -mgit tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a 给tag上密钥git -d tag v0.1 删除tag ###11. tag 推送到远程12345git push origin v1.0git push origin --tags 推送全部 tag如果已经推送到远程, 删除tag会麻烦一点git tag -d v0.9 先删除本地taggit push origin :refs/tags/v0.9 在删除远程tag 拉取单个文件夹参考 初始化新仓库 1234mkdir &lt;repo&gt;cd &lt;repo&gt;git init git remote add origin &lt;name&gt; &lt;url&gt; 打开 sparse-checkout 特性 1git config core.sparsecheckout true 配置.git/info/sparse-checkout, 列出你想要的 checkout 目录 12echo some/dir/ &gt;&gt; .git/info/sparse-checkoutecho another/sub/tree &gt;&gt; .git/info/sparse-checkout 拉取.(remote == name, branch 通常为 master) 1git pull &lt;remote&gt; &lt;branch&gt; Could not read from remote repository两周前还还好的, 今天就不让我push了.原因: 没有匹配正确 ssh 公钥密钥对。 要么是你没有生成对应的公钥密钥对并将公钥部署在 github 上的对应项目， 要么就是生成了密钥对并将公钥部署在了 github 上之后，你的本地目录没有将私钥配置上或者是之前有配置，但是过期了。 好像我之前确实只是拉了 但是没有好好配置. 解决: 重新生成ssh密钥 首先，生成一个公钥密钥对： 1ssh-keygen -t rsa -C “youemail@example.com” -f ~/.ssh/id_rsa 此命令可创建 SSH 公钥密钥对，”youemail@example.com”为你自己的邮箱地址，”id_rsa”为公钥密钥名，可修改。 创建后的公钥密钥对存放在本地目录C:\\Users[UserName].ssh\\文件夹中，mac在用户/xxx/.ssh/, 需要打开finder查看隐藏文件的权限 12345# 显示隐藏文件defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder# 不显示隐藏文件defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder 将公钥部署上github，将（1）中生成的id_rsa.pub文件用文本编辑器打开，复制其中内容。在对应的github项目的“setting”中的“SSH and GPG keys”选择“new SSH key“，将公钥内容粘贴上去，新建一个SSH key。 查看私钥列表的命令为：-l```，如果输出以上命令出现Could not open a connection to your authentication agent.，(mac跳过这步)则再输入```ssh-agent bash```，即可进入SSH bash。添加私钥的命令：```ssh-add ~/.ssh/id_rsa```，此时再查看私钥列表，若已经成功添加，则可以正常地使用 git push 进行对远程仓库的更新了。1234## The agent has no identities.[GithubLink](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent)ssh-add 后没config, 又重启了或者多用户了.1. 查看系统目前的key ssh-add -l1如果输出The agent has no identities. 则表示没有代理. 如果有代理则清除之 ssh-add -D12. 给不同的用户添加进代理 ssh-add ~/.ssh/id_rsassh-add ~/.ssh/another # 如果你有多个用户的话1正确的提示: 2048 8e:71:ad:88:78:80:b2:d9:e1:2d:1d:e4:be:6b:db:8e /Users/aysee/.ssh/id_rsa (RSA)2048 a7:f4:0d:f1:b1:76:0b:bf:ed:9f:53:8c:3f:4c:f4:d6 /Users/aysee/.ssh/another (RSA)1如果使用 ssh-add ~/.ssh/id_rsa的时候报如下错误，则需要先运行一下 ssh-agent bash 命令后再执行 ssh-add ...等命令 Could not open a connection to your authentication agent.12343. 配置 ~/.ssh/config 文件如果只有一个账号,就用github官方的解决方案 Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa1如果github有多个账号, 如下 Host github.comHostName github.comUser gitIdentityFile C:/Users/username/.ssh/id_rsa another (company_email@mail.com)Host github-anotherHostName github.comUser gitIdentityFile C:/Users/username/.ssh/another123456789#### confi文件中常用的字段:Host 指定一个别名（alias）HostName 服务器主机名Port 连接端口User 用户名IdentityFile 指定密钥文件PreferredAuthentications 指定认证方式，通常为 publickey4. 把私钥加进代理 ssh-add -K ~/.ssh/id_rsa``` Use in AndroidStudio参考回退commit: VSC -&gt; Git -&gt; Reset HEAD.其中: Reset Type: Mixed: 代码和commit一起回退, 文件都需要再重新add Soft: 只是commit回退 Hard: 撤销清除整个tree. 别怕, 只是 vsc 被换成了 svn, 去 Preference 里改回来就好 To Commit中的直接写”HEAD”是回退到上一个版本, 撤销上一个commit, 需要”HEAD^”. 报错Everything up-to-date 没有 git add. 没有 git commit -m “提交信息” Couldn’t find remote ref master 仓库里什么都没, readme,.gitignore….. 参考 Everything up-to-date 廖雪峰的git could not read from remote repository ssh多用户 ssh配置config 两个ssh账户","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Git","slug":"Git","permalink":"http://www.fredsun.me/tags/Git/"}]},{"title":"Day25 - Touch","slug":"Day25-Touch","date":"2017-10-24T08:32:00.000Z","updated":"2017-11-12T16:00:00.000Z","comments":true,"path":"2017/10/24/Day25-Touch/","link":"","permalink":"http://www.fredsun.me/2017/10/24/Day25-Touch/","excerpt":"TODO View.onTouchEvent的分析.","text":"TODO View.onTouchEvent的分析. 概念 用户的Touch事件被包装成MotionEvent. 分为: ACTION_DOWN: 表示用户开始触摸. ACTION_MOVE: 表示用户在移动(手指或者其他). ACTION_UP: 表示用户抬起了手指. ACTION_CANCEL: 表示手势被取消了. ACTION_OUTSIDE: 表示用户触碰超出了正常的UI边界. ACTION_POINTER_DOWN: 有一个非主要的手指按下了. 二指触摸时, 第二个手指按下了. ACTION_POINTER_UP: 一个非主要的手指抬起来了. 二指触摸时, 有一个指头抬起来了.(最后抬起的是ACTION_UP). 第一根按下的手指触发ACTION_DOWN事件，之后按下的手指触发ACTION_POINTER_DOWN事件，中间起来的手指触发ACTION_POINTER_UP事件，最后起来的手指触发ACTION_UP事件（即使它不是触发ACTION_DOWN事件的那根手指）。 pointer id可以用于跟踪手指，从按下的那个时刻起pointer id生效，直至起来的那一刻失效，这之间维持不变。 TouchTarget: 消费视图链, 将onTouchEvent\b() 返回true的 view 绑在一起. 类似 Message 链方法 dispatchTouchEvent(): 用来传递触摸事件 返回 true: 消费此事件, 后续事件也分发到这 返回 false: 不消费此事件, 将事件回传到父控件的 后续事件也分发到这12345676. onTouch(): onTouchListener 里被调用的方法, 重写 \btouch 事件时使用, 重写后返回 true 会不再传递 = 消费7. onTouchEvent(): ```dispatchTouchEvent()``` 里的方法, 处理各种DOWN, UP, MOVE 等 Action. 如果重写了 ```onTouch()``` 且返回true, 则不执行. * 返回 true: 自己处理事件, 代码会把这层的```dispatchTouchEvent``` 也置为true, 后续事件也分发到这一层 * 返回 false: 将事件传递给父层的 ```onTouchEvent```, 这一层不会再接收此事件列的后续事件8. onInterceptTouchEvent(): 只存在于 ViewGroup. 是否拦截掉事件 * 返回 true: 拦截事件, 执行自己的 ```onTouchEvent```方法, **此事件序列的后续action直接交给这一层处理, 不会再调用该方法** * 返回 false: 不拦截事件, 传递到更深层的ViewGroup, 如果是 View 就传递给 ViewGroup 父类, 也就是 view, 去 ```dispatchTouchEvent 事件传递图解from如下是在某个 ViewGroup 用 intercept 拦截了 Down事件. 然后在 onTouchEvent 时又被上一层的 onTouchEvent 消费的情况 事件传\u001f递简述from当手指触摸到屏幕, 系统就会调用相应的 View 的 并传入一系列 action.1234567891011121314当有多个层级的 View, 在父层级允许的情况下, 这个 action 会传递到最底层的 View, 所以 touch 事件默认最先调用的是最底层的 View 的 ```onTouchEvent```. 如果 View 的 ```onTouchEvent``` 接收到某个 touch action 并做了处理, 最后有两种返回方式, * return true 会告诉系统, 当前的 View 需要处理这次的 touch 事件, 以后系统发出的 ACTION_MOVE, ACTION_UP 还是需要继续监听并接收的. 而且这次的action已经被消费掉了, 父层是不可能触发 ```onTouchEvent()```.&gt;所以, 每一个action 最多只能由一个 onTouchEvent 返回 true. * 如果return false, 便会通知系统, 当前 view 不关心这一次的 touch 事件, 此时这个 action 会传向父级, 调用父级的 ```onTouchEvent()```. 但是这一次 touch 事件发出的任何 action, 该 view 都不会再接收, ```onTouchEvent```在这一次的 touch 事件中再也不会触发了, 也就是说一旦 view 返回false, 那么之后的 ACTION_MOVE, ACTION_UP 等 action 都不会再传入这个 View. 但是下一次 touch 事件的 action 还是会传进来.前面说了, 底层的 view 能够接收这次事件有一个前提条件: 在父层级允许的情况下. 假设不改变父层级的 dispatch 方法, 系统在调用底层的 ```onTouchEvent``` 之前会先调用父View 的 ```onInterceptTouchEvent```方法判断, 父层View是不是要截获本次touch事件之后的 action. * 如果 ```onInterceptTouchEvent``` 返回了 true, 那么本次touch事件之后的所有 action 不会再向深层 View 传递, 统统传给父层View 的 ```onTouchEvent```. 就是说父层已经截获了这次 touch 事件的后续所有 action. 这些 action 也不再询问 ```onInterceptTouchEvent```, 在这次的 touch 事件之后发出的 action, ```onInterceptTouchEvent``` 不会再调用, 直到下一次touch事件的到来. * 如果 ```onInterceptTouchEvent``` 返回了 false, 那么本次 action 将会传送给更深层的view, 并且之后的每一次 action 都会询问父层的 ```onInterceptTouchEvent``` 需不需要截获本次 touch 事件. 只有 ViewGroup 才有 ```onInterceptTouchEvent ```, 因为一个普通的 view 肯定是位于最深层的view, touch事件能传到这里已经是最后一站了. 肯定会调用View 的 onTouchEvent.对于底层的 view, 有一种方法可以阻止父层截获 touch 事件, 就是调用 ```getParent.requestDisallowInterceptTouchEvent(true)``` 方法.## 事件传递详述#### 一. 当按下屏幕, 点击事件最先传到的是 Activity 的 dispatchTouchEvent() public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 1可以看到 activity 调了 getWindow().superDispatchTouchEvent(ev). 也就是 PhoneWindow 的 @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 1PhoneWindow 又调了 DecorView 的 public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309 我们知道 DecorView 继承自 FrameLayout, FrameLayout 又继承 ViewGroup. 所以其实 activity 的 dispatchTouchEvent 就已经进入了 ViewGroup 的 dispatchTouchEvent. 点击事件从 activity 传递到了 ViewGroup.#### 二. 在 ViewGroup 的 dispatchTouchEvent 中: [from](http://blog.csdn.net/lfdfhl/article/details/50707724)分成五步: * 1. 初始化. 传入的是 ACTION_DOWN, 则认为开始传入新的 touch 事件链, 清空原来记录的状态 * 2. 检查是否拦截(标识 intercepted): * * 1. 在 ACTION_DOWN 或 mFirstTouchTarget链存在的情况下, 如果这里的子view请求了拦截直接置 false. 如果子 view 也没有请求不拦截, 就根据 ```onInterceptTouchEvent``` 返回值判断 * * 2. 对于非 ACTION_DOWN 或 没有 mFirstTouchTarget链\b返回 true * 3. 检查是不是 ACTION_CANCEL(标识 canceled) * 4. touch事件分发.(intercepted 为 false, canceled 也为 false), 然后在 **ACTION_DOWN 的前提下:** * * \b1. newTouchTarget 为空, 当前视图的子view里位于触摸范围内, 判断它们是不是在 mFirstTouchTarget链里, 在就取出这个 TouchTarget链 放进 newTouchTarget链 进入下一步, 不在就递归当前视图的子 view 的子 view 的 dispatchTouchEvent方法, 如果有就新建 newTouchTarget链 加进 mFirstTouchTarget链, 并置标识位 alreadyDispatchedToNewTouchTarget. * * 2. newTouchTarget链 为空, mFirstTouchTarget链不为空(有消费, 但不是这个视图), \b把 touch 点放到mFirstTouchTarget链里 * 5. \b设置 dispatchTouchEvent 的返回值 handled: * * mFirstTouchTarget链为空, 此时还为空就说明不存在消费, 就把自己当作与一个普通的view, 开始 onTouchEvent, handled 为 onTouchEvent 的返回值 * * mFirstTouchTarget链不为空, 并且等于 newTouchTarget 而 alreadyDispatchedToNewTouchTarget 也为 true, ,说明正好是当前视图消费掉了, handled 返回true. 否则传递子视图 dispatchTouchEvent. * 6. 如果发生了canceled或UP, 更新\b链``` java &#123;.line-numbers&#125;public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; /** * 第一步, 初始化 * 因为 ACTION_DOWN 是一系列事件的开端, 当是 ACTION_DOWN 时进行一些初始化操作 * 清除以往的touch状态, 开始新的手势 * 将 mFirstTouchTarget链 设置为 null * 随后在 resetTouchState 中重置 Touch 的标识 *源码注释: * Handle an initial down. **/ if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; /** * 第二步, 设置拦截标识 intercepted * 走到这段代码时的if把情况分成两种: * 1. 当按下 ACTION_DOWN * 2. 当 ACTION_DOWN 被消费后, 后续的 ACTION_MOVE, ACTION_UP, ACTION_CANCEL.(mFirstTouchTarget != null) *源码注释 * Check for interception. **/ final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //FLAG_DISALLOW_INTERCEPT 是否禁用了事件拦截默认false, //子控件可以通过 requestDisallowInterceptTouchEvent 设置父控件不拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 子控件 disallowIntercept, 就直接将事件传递给了 onInterceptTouchEvent, 看下面的分析1 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; //子控件请求父不拦截 intercepted = false; &#125; &#125; else &#123; // 如果是 ACTION_MOVE, ACTION_CANCEL等, intercepted 置为true, 继续拦截事件 // 也就是概念里提到的, // 如果 dispatchTouchEvent 消费了 ACTION_DOWN, 后续事件也会被 ViewGroup 拦截 //源码注释: // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; /** * 第三步 检查canceled **/ // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 更新消费视图链, 如果有第二个手指触摸 // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; /** * 第四步 事件分发 (不是取消不是拦截时进行) **/ if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 处理 ACTION_DOWN if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; //4.1 if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; //依靠Touch坐标寻找子View来接收touch事件 final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // for循环 遍历 ViewGroup 底下全部子 view, 判断哪个 View 接收 touch 事件 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); // 如果 view 能在触摸范围内, 也在可接收触摸的视图链里面 if (newTouchTarget != null) &#123; // 找到了接收事件的子View, 跳出循环 // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); /** * \b将 touch 事件分给子 view 去做 (分发的核心) * 说明1: if 中的 dispatchTransformedTouchEvent 内部 会递归调用 当前 view 的子 view 的 dispatchTouchEvent. * 如果子 view 是 ViewGroup, 就继续 dispatchTouchEvent. * 如果子 view 是 View, 则调用 onTouchEvent, * * 返回true, 说明当前 ViewGroup 消费了事件, 接下来处理 3 步: * 1. 给 newTouchTarget 赋值 * 2. 置标识 alreadyDispatchedToNewTouchTarget为 true * 3. break 跳出循环 * * 说明2: addTouchTarget(). ViewGroup 有一个静态内部类 TouchTarget, 用于存储拦截\b触摸的 view. newTouchTarget 和 mFirstTouchTarget 都是 TouchTarget. * 注意: 这一步操作是在if(...ACTION_DOWN)的大判断里的, 如果是 ACTION_MOVE, ACTION_CANCEL, 则直接去判断 mFirstTouchTarget. * 所以如果一个 view 不处理 ACTION_DOWN, 那么系统是不会将ACTION_MOVE, ACTION_CANCEL传过来的 * 总结: * 对于 ACTION_DOWN 的处理体现在, 如果 dispatchTransformedTouchEvent(), 该方法返回boolean: * true -&gt; 事件被消费 -&gt; mFirstTouchTarget != null; * false -&gt; 事件未被消费 -&gt; mFirstTouchTarget == null; **/ if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125;// for循环结束 if (preorderedList != null) preorderedList.clear(); &#125; //如果遍历后\b没有子view接收事件, 并且 mFirstTouchTarget 不为空, 就把事件扔给最初的TouchTarget if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; //newTouchTarget指向了最初的TouchTarget newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; /** * 第五步 对处理完的touch链进行判断 * 现在的 mFirstTouchTarget 有两种状态 **/ // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; //1. mFirstTouchTarget 为 null, 就是说 touch 没被消费 //即 没有找到消费 touch 事件的子组件 或 touch事件被拦截 //那么就像普通不消费事件的 view 一样, 叫此 view 的上层 ViewGroup 的 onTouchEvent 处理事件. //通过 dispatchTransformedTouchEvent, 并将第三个参数置为null 实现. // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 如果找到了消费事件的 view, 且后续事件可以传递给此 view // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //循环处理 被消费的 touch 链的各个 ACTION. while (target != null) &#123; final TouchTarget next = target.next; // 只有 ACTION_DOWN时才能设置的 alreadyDispatchedToNewTouchTarget == true. //所以这里是对 ACTION_DOWN 做判断, 且当前消费视图链吻合, 就是已被处理, 则忽略 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; //对于非 ACTION_DOWN 事件, 继续传递给目标子组件进行处理 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 若触摸点发生了 up 或 cancel, 则更新 TouchTarget 链表 //源码注释: // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125; 分析1 ViewGroup.onInterceptTouchEvent123456789public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false;&#125; 如果自己不重写, 默认是false; 分析2 ViewGroup.dispatchTransformedTouchEvent如果第三个参数 child 设为view, 就调用super.dispatchTouchEvent.如果 child 为 null, 就调用child的dispatchTouchEvent.123456789101112131415161718private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled;...// 删掉部分后就是根据是否传进了 child 判断分发给谁 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ...&#125; 4. 在 view 中的 dispatchTouchEvent从继承上, Button extends TextView extends View当按下 Button 时, 会先调用 dispatchTouchEvent, Button 和 TextView 都没有重写, 默认在 View 里重写.在 dispatchTouchEvent 中:&#123;.line-numbers&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; //抽出重要的部分大致是:1234567public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; 只有当: 1. 控件\b创建了 mOnTouchListener 2. 控件 ENABLE 3. mOnTouchListener 的 onTouch 方法返回值为true 三步都具备时, 就不再进入 方法.123那么, 要么 onTouch 返回true, 或者 onTouchEvent 返回true时, dispathTouchEvent 返回true#### 5. TODO View 的 onTouchEVent public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we&apos;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; }``` 大概的是如果这个view可点击, 一定返回true, 否则一定返回false.注意点: 如果一个控件不是 ENABLE, 那么它在第 2 步就永远过不去, 如果还想监听它的 touch 事件, 就得自己重写它的 onTouchEvent 方法. 如果一个控件滑不起来(或只收到ACTION_DOWN, 收不到ACTION_MOVE等), 加 xml 中 clickable = “true”, 或者 onTouch 方法返回 true, 或 onTouchEvent 返回 true 拦截不等于消费. 得有一方的 onTouchEvent 返回 true 才是消费总结: from 如果在某个层级没有处理ACTION_DOWN事件，那么该层就再也收不到后续的Touch事件了直到下一次ACTION_DOWN事件说明： a.某个层级没有处理某个事件指的是它以及它的子View都没有处理该事件。 b.这条规则不适用于Activity层（它是顶层），它们可以收到每一个Touch事件。 c.如果没有处理ACTION_MOVE这类事件，不会有任何影响。 如果ACTION_DOWN事件发生在某个View的范围之内，则后续的ACTION_MOVE，ACTION_UP和ACTION_CANCEL等事件都将被发往该View，即使事件已经出界了 如果一个ACTION_DOWN事件被父View拦截了，则任何子View不会再收到任何Touch事件了如果一个非ACTION_DOWN事件被父View拦截了，则那些上次处理了ACTION_DOWN事件的子View会收到一个ACTION_CANCEL事件，之后不会再收到任何Touch事件了，即使父View不再拦截后续的Touch事件 如果父View决定处理Touch事件或者子View没有处理Touch事件，则父View按照普通View的处理方式处理Touch事件，否则它根本不处理Touch事件 如果父View在onInterceptTouchEvent中拦截了事件，则onInterceptTouchEvent中不会再收到Touch事件了，事件被直接交给它自己处理（按照普通View的处理方式） ACTION_DOWN 去探路, 找到消费事件的view, ACTION_MOVE 直接传给消费者了. Q&amp;A: from Q: onTouch 和 onTouchEvent 区别 都是在 View.dispatchTouchEvent, 但 onTouch 先于 onTouchEvent 执行. 如果 onTouch 返回true, onTouchEvent 得不到执行 如果一个控件是非enable, 走不到ontouch的判断, 就只能依靠 onTouchEvent 来监听 参考 事件分发系统简述 Touch系统简介 熟悉touch流程的栗子 ViewGroup.dispatchTouchEvent详述 详述2 Touch事件总结 图解","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Touch","slug":"Touch","permalink":"http://www.fredsun.me/tags/Touch/"}]},{"title":"Day24 - Retrofit + Logger","slug":"Day24-Retrofit+Logger","date":"2017-09-22T06:20:00.000Z","updated":"2017-12-05T16:00:00.000Z","comments":true,"path":"2017/09/22/Day24-Retrofit+Logger/","link":"","permalink":"http://www.fredsun.me/2017/09/22/Day24-Retrofit+Logger/","excerpt":"目的: 通过 retrofit/okhttp 的支持, 先打印出混着的网络请求log 然后通过logger打印成下面这样","text":"目的: 通过 retrofit/okhttp 的支持, 先打印出混着的网络请求log 然后通过logger打印成下面这样 一. 先打印出log0. 借着 okhttp 提供了 interceptor 可以配合 Logger过去跟服务器的接口连调我是打印出 token, 然后在 postman 创建链接拼入参数(怕玩意来个空就崩。。), 后来大家配合的好点儿了, 不怕崩就直接在log里看, 但是看到超长的json…还是得复制出来, 然后用Notepad++之类的格式化来看, 既然okhttp提供了interceptor, 那就来试试看吧 1. 添加 square 的 logging-interceptor1compile &apos;com.squareup.okhttp3:logging-interceptor:3.5.0&apos; 2. 创建自己的 LogInterceptor123456public class HttpLogger implements HttpLoggingInterceptor.Logger &#123; @Override public void log(String message) &#123; Log.d(\"HttpLogInfo\", message); &#125; &#125; 3. 把 LogInterceptor 集成进 okhttp1234567891011private OkHttpClient okhttpclient() &#123; if (mOkHttpClient == null) &#123; HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor(new HttpLogger()); logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); mOkHttpClient = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .addNetworkInterceptor(logInterceptor) .build(); &#125; return mOkHttpClient; &#125; 3.1 为啥是 addNetworkInterceptor 而不是 addInterceptor 在给okhttp扩展的时候 应该是 addNetworkInterceptor 而不是 addInterceptor, 因为有时候可能会通过cookieJar在header里面添加一些持久化的cookie或session信息. 这样请求头就打印不出信息了 来看下Realcall.java的源码12345678910111213141516Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; okhttp在做请求的时候会先构造拦截链, 然后将所有的拦截器都放入一个ArrayList, 添加顺序和代码的一样:1234567client.interceptors());retryAndFollowUpInterceptor);BridgeInterceptor(client.cookieJar()));CacheInterceptor(client.internalCache()));ConnectInterceptor(client));client.networkInterceptors()); CallServerInterceptor(forWebSocket)); 当使用 addInterceptor 添加拦截器时, 会直接通过 client.networkInterceptors() 添加, 然后按照顺序拦截的时候, 会是 HttpLoggingInterceptor 先执行, 然后打印出日志, 然后才会执行 CookieJar 包装的拦截器 BridgeInterceptor, 这样导致我们添加到 header 中的 cookie 等信息不会打印出来 二. 接下来开始格式化 Logger4. 添加 Logger1compile &apos;com.orhanobut:logger:2.1.1&apos; 5. 用 LogUtil 封装 Logger1234567891011121314151617181920212223242526272829303132333435363738394041public class LogUtil &#123; /** * 初始化log工具，在app入口处调用 * */ public static void init() &#123; FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .showThreadInfo(false) .methodOffset(2)//隐藏内部方法 .tag(\"My custom tag\") .build(); Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)&#123; @Override public boolean isLoggable(int priority, String tag) &#123; return BuildConfig.DEBUG;//是否显示logger &#125; &#125;); &#125; public static void d(String message) &#123; Logger.d(message); &#125; public static void i(String message) &#123; Logger.i(message); &#125; public static void w(String message, Throwable e) &#123; String info = e != null ? e.toString() : \"null\"; Logger.w(message + \"：\" + info); &#125; public static void e(String message, Throwable e) &#123; Logger.e(e, message); &#125; public static void json(String json) &#123; Logger.json(json); &#125;&#125; 6. 初始化 LogUtil记得把 App 设为清单里的 Application1234567public class App extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LogUtil.init(); &#125;&#125; 7.格式化json(添加空格, \\xx转义成汉字)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class JsonUtil &#123; /** * 格式化json字符串 * * @param jsonStr 需要格式化的json串 * @return 格式化后的json串 */ public static String formatJson(String jsonStr) &#123; if (null == jsonStr || \"\".equals(jsonStr)) return \"\"; StringBuilder sb = new StringBuilder(); char last = '\\0'; char current = '\\0'; int indent = 0; for (int i = 0; i &lt; jsonStr.length(); i++) &#123; last = current; current = jsonStr.charAt(i); //遇到&#123; [换行，且下一行缩进 switch (current) &#123; case '&#123;': case '[': sb.append(current); sb.append('\\n'); indent++; addIndentBlank(sb, indent); break; //遇到&#125; ]换行，当前行缩进 case '&#125;': case ']': sb.append('\\n'); indent--; addIndentBlank(sb, indent); sb.append(current); break; //遇到,换行 case ',': sb.append(current); if (last != '\\\\') &#123; sb.append('\\n'); addIndentBlank(sb, indent); &#125; break; default: sb.append(current); &#125; &#125; return sb.toString(); &#125; /** * 添加space * * @param sb * @param indent */ private static void addIndentBlank(StringBuilder sb, int indent) &#123; for (int i = 0; i &lt; indent; i++) &#123; sb.append('\\t'); &#125; &#125; /** * http 请求数据返回 json 中中文字符为 unicode 编码转汉字转码 * * @param theString * @return 转化后的结果. */ public static String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &lt; len; ) &#123; aChar = theString.charAt(x++); if (aChar == '\\\\') &#123; aChar = theString.charAt(x++); if (aChar == 'u') &#123; int value = 0; for (int i = 0; i &lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': value = (value &lt;&lt; 4) + aChar - '0'; break; case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': value = (value &lt;&lt; 4) + 10 + aChar - 'a'; break; case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': value = (value &lt;&lt; 4) + 10 + aChar - 'A'; break; default: throw new IllegalArgumentException( \"Malformed \\\\uxxxx encoding.\"); &#125; &#125; outBuffer.append((char) value); &#125; else &#123; if (aChar == 't') aChar = '\\t'; else if (aChar == 'r') aChar = '\\r'; else if (aChar == 'n') aChar = '\\n'; else if (aChar == 'f') aChar = '\\f'; outBuffer.append(aChar); &#125; &#125; else outBuffer.append(aChar); &#125; return outBuffer.toString(); &#125;&#125; 8. 将 Logger 加入 LogInterceptor把第2步的123456public class HttpLogger implements HttpLoggingInterceptor.Logger &#123; @Override public void log(String message) &#123; Log.d(\"HttpLogInfo\", message); &#125; &#125; 替换为123456789101112131415161718192021public class HttpLogger implements HttpLoggingInterceptor.Logger &#123; private StringBuilder mMessage = new StringBuilder(); @Override public void log(String message) &#123; // 请求或者响应开始 if (message.startsWith(\"--&gt; POST\")) &#123; mMessage.setLength(0); &#125; // 以&#123;&#125;或者[]形式的说明是响应结果的json数据，需要进行格式化 if ((message.startsWith(\"&#123;\") &amp;&amp; message.endsWith(\"&#125;\")) || (message.startsWith(\"[\") &amp;&amp; message.endsWith(\"]\"))) &#123; message = JsonUtil.formatJson(message); &#125; mMessage.append(message.concat(\"\\n\")); // 请求或者响应结束，打印整条日志 if (message.startsWith(\"&lt;-- END HTTP\")) &#123; LogUtil.d(mMessage.toString()); &#125; &#125; &#125; 让Log以LogUtil.d的方式输出 参考掘金 | 利用 logger 打印完整的 okhttp 网络请求和响应日志 只是将Logger1.5升到了2.1，更新了部分方法，其他地方相同","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.fredsun.me/tags/Retrofit/"},{"name":"Logger","slug":"Logger","permalink":"http://www.fredsun.me/tags/Logger/"},{"name":"Interceptor","slug":"Interceptor","permalink":"http://www.fredsun.me/tags/Interceptor/"}]},{"title":"Day23 - Retrofit + RxJava + RecyclerView","slug":"Day23-RxJava+Retrofit+RecyclerView","date":"2017-09-22T06:01:00.000Z","updated":"2017-12-06T09:19:57.836Z","comments":true,"path":"2017/09/22/Day23-RxJava+Retrofit+RecyclerView/","link":"","permalink":"http://www.fredsun.me/2017/09/22/Day23-RxJava+Retrofit+RecyclerView/","excerpt":"Retrofit 上手","text":"Retrofit 上手 PS: 如何解决上游速度过快的方式rxjava1.x 解决上游速度过快的方式1234567891011121314151617181920212223Observable.from(stringList).observeOn(Schedulers.io()).subscribe(new Subscriber&lt;String&gt;() &#123;@Overridepublic void onStart() &#123;request(1); // 取出一条新数据&#125;@Overridepublic void onCompleted() &#123;&#125;@Overridepublic void onError(Throwable e) &#123;e.printStackTrace();&#125;@Overridepublic void onNext(ResourceUpdate resourceUpdate) &#123;// TODO 执行下游处理操作...request(1); // 取出一条新数据&#125;&#125;); RxJava组成1. 上游 Observable/Flowable2. 下游 多种无参的subscribe()表示下游不关心数据类型带Cunsumer的表示下游只关心 onNext, 其他的装没看见123456* public final Disposable subscribe() &#123;&#125;* public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;* public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125;* public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;* public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;* public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 上有和下游之间可以添加各种参数 3. 水管 subscribe4. 指定上游线程 subscribeOn()多次指定上游线程, 只有第一次有效 5. 指定下游线程 observeOn()下游线程可以多次指定 RxJava提供的线程 Schedulers.io(), 代表io操作线程, 通常用于网络/读写等密集型操作 Schedulers.computation, 代表CPu密集型计算 Schedulers.newThread(), 代表一个常规的新线程 AndroidSchedulers.mainThread(), 代表Android的主线程RxJava内部使用线程池来维护, 所以效率也比较高 AndroidSchedulers.mainThread()是RxAndroid包里的 6.变换操作符Map截获事件水流 FlatMap比Map更复杂, 将上游的Observable转化成多个Observable, 然后将他们发射的事件合并后放进一个单独的Observable里, 但是不保证事件顺序 concatMap保证事件顺序的 FlatMap zip将两个不同线程的 Observable 合并成一个 Observable, 短的发完了, 就彻底结束水流用处: 一个数据需要两个接口的参数拼在一起实现 Backpressure(Observable 做上游时)如果两个线程的两个水管 Observable, 一个不停的发, 另一个速度过慢, 那么会创建一个水缸(队列)积压发的过快的水管1的数据, 但是如果积压过多会OOM, 所以大数据用Flowable, 小数据流用Observable.(同一个线程不会, 因为需要消费完了才能发, 但是异步线程因为线程间无法直接通信, 所以会积压) 背压rxjava1.x 时下游通过背压控制上游流速. 上游会给下游 set 一个 producer, 然后下游通过 producer向上游请求n个数据, 这样上游就有记录下游请求了多少个数据, 然后下游请求了多少个上游就给多少个.一般来说每个节点都有缓存, 但是rxjava1.x有些操作符不支持背压, 也就是说上游不理会下游返回的 producer, 一直向下游丢数据,如果下游的缓存爆了, 就会抛出 MissingBackpressureException, 也就是背压失效.rxjava2.x 里将背压逻辑移到了 Flowable, 所以 Flowable 支持背压. filter过滤上游的内容 sample每隔一定事件取一部分放进水缸 以上两种都以丢失数据为代价减小放进水缸的数据量 睡 线程让快的线程睡1秒再发 但是如果下游处理时间过慢(超过1秒), 依然丢失事件 Flowable &amp; request &amp; BackpressureStrategy12345678910111213141516171819202122232425262728293031323334353637383940Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"emit 1\"); emitter.onNext(1); Log.d(TAG, \"emit 2\"); emitter.onNext(2); Log.d(TAG, \"emit 3\"); emitter.onNext(3); Log.d(TAG, \"emit complete\"); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(Long.MAX_VALUE); //注意这句代码 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"onNext: \" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;; upstream.subscribe(downstream); 下游的request同一线程时, s.request(Long.MAX_VALUE) 告诉上游下游可以接受的消息数量, 如果不写则上游认为下游没有能力接收水流, 上游直接 MissingBackpressureException.不同线程时, 下游默认带了128大小的水缸缓存, 所以不会报错, 但是下游因为没说自己能接收多少水流, 所以下游也无法消费这个事件, 直到mSubscription.request(x), 下游才消费x个水流 BackpressureStrategy 设为ERROR, 当水缸满了, 直接抛出 MissingBackpressureException 设为BUFFER, 水缸无限大, 相当于把 Flowable 换成了 Observable 设为DROP, 如果没执行到最后一个则何时 REQUEST, 执行到第几个 设为LATEST, 最后一定能执行到最后一个 REQUEST onBackpressure…（当上游无法被我们控制时） 设为onBackpressureBuffer 设为onBackpressureDrop 设为onBackpressureLatest 上游的requested - emitter.requested()对下游能接收消息数量的响应, 若发出的消息超过了下游设置的request, 则抛出 MissingBackpressureException. 每次发出96条 实践Retrofit连续请求, 结果用RecyclerView展示参考分为两个请求, 第一个请求, 根据经纬度向百度请求, 拿到转换出的城市名, 第二个请求, 请求和风天气, 将城市名转换成城市名对应的天气 准备好百度地图的城市json对应的bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class LocationEntity &#123; /** * status : OK * result : &#123;&quot;location&quot;:&#123;&quot;lng&quot;:121.490523,&quot;lat&quot;:31.407452&#125;,&quot;formatted_address&quot;:&quot;上海市宝山区牡丹江路1599号&quot;,&quot;business&quot;:&quot;友谊路,北翼商业街,吴淞&quot;,&quot;addressComponent&quot;:&#123;&quot;city&quot;:&quot;上海市&quot;,&quot;direction&quot;:&quot;near&quot;,&quot;distance&quot;:&quot;0&quot;,&quot;district&quot;:&quot;宝山区&quot;,&quot;province&quot;:&quot;上海市&quot;,&quot;street&quot;:&quot;牡丹江路&quot;,&quot;street_number&quot;:&quot;1599号&quot;&#125;,&quot;cityCode&quot;:289&#125; */ private String status; private ResultBean result; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125; public ResultBean getResult() &#123; return result; &#125; public void setResult(ResultBean result) &#123; this.result = result; &#125; public static class ResultBean &#123; /** * location : &#123;&quot;lng&quot;:121.490523,&quot;lat&quot;:31.407452&#125; * formatted_address : 上海市宝山区牡丹江路1599号 * business : 友谊路,北翼商业街,吴淞 * addressComponent : &#123;&quot;city&quot;:&quot;上海市&quot;,&quot;direction&quot;:&quot;near&quot;,&quot;distance&quot;:&quot;0&quot;,&quot;district&quot;:&quot;宝山区&quot;,&quot;province&quot;:&quot;上海市&quot;,&quot;street&quot;:&quot;牡丹江路&quot;,&quot;street_number&quot;:&quot;1599号&quot;&#125; * cityCode : 289 */ private LocationBean location; private String formatted_address; private String business; private AddressComponentBean addressComponent; private int cityCode; public LocationBean getLocation() &#123; return location; &#125; public void setLocation(LocationBean location) &#123; this.location = location; &#125; public String getFormatted_address() &#123; return formatted_address; &#125; public void setFormatted_address(String formatted_address) &#123; this.formatted_address = formatted_address; &#125; public String getBusiness() &#123; return business; &#125; public void setBusiness(String business) &#123; this.business = business; &#125; public AddressComponentBean getAddressComponent() &#123; return addressComponent; &#125; public void setAddressComponent(AddressComponentBean addressComponent) &#123; this.addressComponent = addressComponent; &#125; public int getCityCode() &#123; return cityCode; &#125; public void setCityCode(int cityCode) &#123; this.cityCode = cityCode; &#125; public static class LocationBean &#123; /** * lng : 121.490523 * lat : 31.407452 */ private double lng; private double lat; public double getLng() &#123; return lng; &#125; public void setLng(double lng) &#123; this.lng = lng; &#125; public double getLat() &#123; return lat; &#125; public void setLat(double lat) &#123; this.lat = lat; &#125; &#125; public static class AddressComponentBean &#123; /** * city : 上海市 * direction : near * distance : 0 * district : 宝山区 * province : 上海市 * street : 牡丹江路 * street_number : 1599号 */ private String city; private String direction; private String distance; private String district; private String province; private String street; private String street_number; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getDirection() &#123; return direction; &#125; public void setDirection(String direction) &#123; this.direction = direction; &#125; public String getDistance() &#123; return distance; &#125; public void setDistance(String distance) &#123; this.distance = distance; &#125; public String getDistrict() &#123; return district; &#125; public void setDistrict(String district) &#123; this.district = district; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; public String getStreet_number() &#123; return street_number; &#125; public void setStreet_number(String street_number) &#123; this.street_number = street_number; &#125; &#125; &#125;&#125; 准备 Rxjava 的 interface 1234567891011121314public interface Api &#123; @GET(\"weather\") Observable&lt;Weather2&gt; getWeatherRx( @Query(\"city\")String city, @Query(\"key\")String key); @GET(\"geocoder\") Observable&lt;LocationEntity&gt; getLoation( @Query(\"location\") String location, @Query(\"output\") String output, @Query(\"key\") String key );&#125; 创建Retrofit 123456789101112131415161718192021222324252627282930313233343536373839404142public class RetrofitCreater &#123; public static Retrofit createWeather() &#123; OkHttpClient.Builder builder = new OkHttpClient().newBuilder(); builder.readTimeout(10, TimeUnit.SECONDS); builder.connectTimeout(9, TimeUnit.SECONDS); builder.retryOnConnectionFailure(true);//错误时重复请求 builder.connectTimeout(15, TimeUnit.SECONDS); if (BuildConfig.DEBUG) &#123; HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(new HttpLogger()); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); builder.addNetworkInterceptor(interceptor); &#125; return new Retrofit.Builder().baseUrl(\"https://free-api.heweather.com/v5/\") .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125; public static Retrofit createLoc() &#123; OkHttpClient.Builder builder = new OkHttpClient().newBuilder(); builder.readTimeout(10, TimeUnit.SECONDS); builder.connectTimeout(9, TimeUnit.SECONDS); builder.retryOnConnectionFailure(true);//错误时重复请求 builder.connectTimeout(15, TimeUnit.SECONDS); if (BuildConfig.DEBUG) &#123; HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(new HttpLogger()); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); builder.addNetworkInterceptor(interceptor); &#125; return new Retrofit.Builder().baseUrl(\"http://api.map.baidu.com/\") .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125;&#125; 调用Retrofit(无adapter) 1234567891011121314151617181920212223242526272829private void requestRxLocation() &#123; Retrofit weatherRetrofit = RetrofitCreater.createWeather(); final Api weatherApi = weatherRetrofit.create(Api.class); final Retrofit retrofitLoc = RetrofitCreater.createLoc(); Api locApi = retrofitLoc.create(Api.class); locApi.getLoation(\"39.90400,116.39100\", \"json\", \"6eea93095ae93db2c77be9ac910ff311\") .flatMap(new Function&lt;LocationEntity, ObservableSource&lt;Weather2&gt;&gt;() &#123; @Override public ObservableSource&lt;Weather2&gt; apply(LocationEntity locationEntity) throws Exception &#123; Log.i(tag, locationEntity.getResult().getAddressComponent().getCity()+\"\"); return weatherApi.getWeatherRx(locationEntity.getResult().getAddressComponent().getCity(), \"你的和风天气key\"); //拿到城市名, 开始请求天气接口 &#125; &#125;).map(new Function&lt;Weather2, String&gt;() &#123; @Override public String apply(Weather2 weather2) throws Exception &#123; String text = weather2.getHeWeather5().get(0).getBasic().getCity(); return text; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.i(tag,\"accept\"+s); &#125; &#125;);&#125; — 加入RecyclerView — 创建adapter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class WeatherAdapter extends RecyclerView.Adapter&lt;WeatherAdapter.ViewHolder&gt; &#123; private List&lt;Weather2.HeWeather5Bean&gt; mItems; private Context mContext; private PostItemListener mItemListener; public class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener&#123; public TextView titleTv; PostItemListener mItemListener; public ViewHolder(View itemView, PostItemListener postItemListener) &#123; super(itemView); titleTv = (TextView) itemView.findViewById(android.R.id.text1); this.mItemListener = postItemListener; itemView.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; Weather2.HeWeather5Bean item = getItem(getAdapterPosition()); this.mItemListener.onPostClick(Integer.valueOf(0)); notifyDataSetChanged(); &#125; &#125; public WeatherAdapter(Context context, List&lt;Weather2.HeWeather5Bean&gt; posts, PostItemListener itemListener) &#123; mItems = posts; mContext = context; mItemListener = itemListener; &#125; @Override public WeatherAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; Context context = parent.getContext(); LayoutInflater inflater = LayoutInflater.from(context); View postView = inflater.inflate(android.R.layout.simple_list_item_1, parent, false); ViewHolder viewHolder = new ViewHolder(postView, this.mItemListener); return viewHolder; &#125; @Override public void onBindViewHolder(WeatherAdapter.ViewHolder holder, int position) &#123; Weather2.HeWeather5Bean item = mItems.get(position); TextView textView = holder.titleTv; textView.setText(item.getBasic().getCity()); &#125; @Override public int getItemCount() &#123; return mItems.size(); &#125; public void updateAnswers(List&lt;Weather2.HeWeather5Bean&gt; items) &#123; mItems = items; notifyDataSetChanged(); &#125; private Weather2.HeWeather5Bean getItem(int adapterPosition) &#123; return mItems.get(adapterPosition); &#125; public interface PostItemListener &#123; void onPostClick(long id); &#125;&#125; main里创建adapter 1234567891011121314mAdapter = new WeatherAdapter(this, new ArrayList&lt;Weather2.HeWeather5Bean&gt;(0), new WeatherAdapter.PostItemListener() &#123; @Override public void onPostClick(long id) &#123; Toast.makeText(MainActivity.this, &quot;Post id is&quot; + id, Toast.LENGTH_SHORT).show(); &#125; &#125;); mRecyclerView = (RecyclerView) findViewById(R.id.recycler); RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(layoutManager); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setHasFixedSize(true); RecyclerView.ItemDecoration itemDecoration = new DividerItemDecoration(this, DividerItemDecoration.VERTICAL); mRecyclerView.addItemDecoration(itemDecoration); 调用retrofit(有adapter) 123456789101112131415161718192021222324252627Retrofit weatherRetrofit = RetrofitCreater.createWeather();final Api weatherApi = weatherRetrofit.create(Api.class);final Retrofit retrofitLoc = RetrofitCreater.createLoc();Api locApi = retrofitLoc.create(Api.class);locApi.getLoation(&quot;39.90400,116.39100&quot;, &quot;json&quot;, &quot;6eea93095ae93db2c77be9ac910ff311&quot;) .flatMap(new Function&lt;LocationEntity, ObservableSource&lt;Weather2&gt;&gt;() &#123; @Override public ObservableSource&lt;Weather2&gt; apply(LocationEntity locationEntity) throws Exception &#123; Log.i(TAG, locationEntity.getResult().getAddressComponent().getCity()+&quot;&quot;); return weatherApi.getWeatherRx(locationEntity.getResult().getAddressComponent().getCity(), &quot;2cad1fb8a48d418faa66cf5f8aba3f7e&quot;); &#125; &#125;).map(new Function&lt;Weather2, Weather2&gt;() &#123; @Override public Weather2 apply(Weather2 weather2) throws Exception &#123; String text = weather2.getHeWeather5().get(0).getBasic().getCity(); return weather2; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Weather2&gt;() &#123; @Override public void accept(Weather2 weather2) throws Exception &#123; mAdapter.updateAnswers(weather2.getHeWeather5()); &#125; &#125;); database 参考使用RxJava+Retrofit完成同步连续请求","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.fredsun.me/tags/Retrofit/"},{"name":"RxJava","slug":"RxJava","permalink":"http://www.fredsun.me/tags/RxJava/"}]},{"title":"Day22 - Retrofit","slug":"Day22-Retrofit","date":"2017-09-22T06:00:00.000Z","updated":"2017-10-20T07:28:28.589Z","comments":true,"path":"2017/09/22/Day22-Retrofit/","link":"","permalink":"http://www.fredsun.me/2017/09/22/Day22-Retrofit/","excerpt":"Retrofit 初探","text":"Retrofit 初探 tips 解特殊json okhttp2 -&gt; 3, 将set模式改成了builder模式Retrofit使用From1. 添加依赖和网络权限build.gradle1234dependencies &#123; compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos; // Retrofit库 &#125; Manifest1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2. 创建接受服务器返回的数据的类12345678910111213141516171819202122public class Translation &#123; private int status; private content content; private static class content &#123; private String from; private String to; private String vendor; private String out; private int errNo; &#125; //定义 输出返回数据 的方法 public void show() &#123; System.out.println(status); System.out.println(content.from); System.out.println(content.to); System.out.println(content.vendor); System.out.println(content.out); System.out.println(content.errNo); &#125;&#125; 3. 创建用于描述网络请求的接口123456789public interface GetRequest_Interface &#123; @GET(&quot;ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world&quot;) Call&lt;Translation&gt; getCall(); // 注解里传入 网络请求 的部分URL地址 // Retrofit把网络请求的URL分成了两部分：一部分放在Retrofit对象里，另一部分放在网络请求接口里 // 如果接口里的url是一个完整的网址，那么放在Retrofit对象里的URL可以忽略 // getCall()是接受网络请求数据的方法&#125; 3.1 接口拆分 4. 创建 Retrofit 对象4.1 数据解析器(Converter)1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://fy.iciba.com/&quot;) // 设置 网络请求 Url .addConverterFactory(GsonConverterFactory.create()) //设置使用Gson解析(记得加入依赖) .build(); 数据解析器 Gradle依赖 Gson com.squareup.retrofit2:converter-gson:2.0.2 Jackson com.squareup.retrofit2:converter-jackson:2.0.2 Simple XML com.squareup.retrofit2:converter-simplexml:2.0.2 Protobuf com.squareup.retrofit2:converter-protobuf:2.0.2 Moshi com.squareup.retrofit2:converter-moshi:2.0.2 Wire com.squareup.retrofit2:converter-wire:2.0.2 Scalars com.squareup.retrofit2:converter-scalars:2.0.2 4.2 网络请求适配器(CallAdapter) 网络请求适配器 Gradle依赖 guava com.squareup.retrofit2:adapter-guava:2.0.2 Java8 com.squareup.retrofit2:adapter-java8:2.0.2 rxjava com.squareup.retrofit2:adapter-rxjava:2.0.2 5. 创建 网络请求接口实例6. 发送网络请求（异步 / 同步）7. 处理返回的数据 三步如下:1234567891011121314151617181920212223242526272829303132333435363738394041public class GetRequest extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); request(); // 使用Retrofit封装的方法 &#125; public void request() &#123; //步骤4:创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://fy.iciba.com/&quot;) // 设置 网络请求 Url .addConverterFactory(GsonConverterFactory.create()) //设置使用Gson解析(记得加入依赖) .build(); // 步骤5:创建 网络请求接口 的实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); //对 发送请求 进行封装 Call&lt;Translation&gt; call = request.getCall(); //步骤6:发送网络请求(异步) call.enqueue(new Callback&lt;Translation&gt;() &#123; //请求成功时回调 @Override public void onResponse(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response) &#123; // 步骤7：处理返回的数据结果 response.body().show(); &#125; //请求失败时回调 @Override public void onFailure(Call&lt;Translation&gt; call, Throwable throwable) &#123; System.out.println(&quot;连接失败&quot;); &#125; &#125;); &#125;&#125; 6.2 同步请求(记得不在主线程请求)12Response&lt;Translation&gt; response = call.execute(); response.body().show(); 加上gson解析需要的依赖 'com.squareup.retrofit2:converter-gson:2.0.2'```123456789101112131415# Retrofit进阶## okhttp3 独立出来建 builder##### HttpLoggingInterceptor 拦截日志&gt; 原本retrofit 的 set log level已经删除, 通过okhttp拦截##### retryOnConnectionFailure(true) 设置出现错误进行重新连接##### connectTimeout(15, TimeUnit.SECONDS) 设置超时时间##### addNetworkInterceptor, 让所有的网络请求都加上拦截器,##Retrofit + RxJava和普通的Retrofit请求比只是多了三步1. api注解时回调是 Observable public interface Api { @GET(“weather?key=2cad1fb8a48d418faa66cf5f8aba3f7e”) Observable getWeatherRx(@Query(“city”)String key);}12. 构造Retrofit时加入```addCallAdapterFactory(RxJava2CallAdapterFactory.create()) 12345Retrofit weatherRetrofit = new Retrofit.Builder().baseUrl(&quot;https://free-api.heweather.com/v5/&quot;) .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build() 将步骤6的123456789101112131415161718192021222324252627282930```Api api = weatherRetrofit.create(Api.class); api.getWeatherRx(&quot;CN101010100&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Weather2&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; mDisposable = d; Log.i(tag, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Weather2 value) &#123; Log.i(tag, value.getHeWeather5().get(0).getBasic().getCity().toString()); Log.i(tag, &quot;onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(MainActivity.this, &quot;请求错误&quot;, Toast.LENGTH_SHORT).show(); Log.i(tag, &quot;onError&quot;); &#125; @Override public void onComplete() &#123; Toast.makeText(MainActivity.this, &quot;请求正确&quot;, Toast.LENGTH_SHORT).show(); Log.i(tag, &quot;onComplete&quot;); &#125; &#125;); 用法:设置全局变量 mDisposable, 在 activity 退出的时候调用 mDisposable.dispose(); 参考drakeet | Retrofit 2.0 + OkHttp 3.0 配置","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.fredsun.me/tags/Retrofit/"},{"name":"RxJava","slug":"RxJava","permalink":"http://www.fredsun.me/tags/RxJava/"}]},{"title":"Day21 - 进程和线程","slug":"Day21-进程和线程","date":"2017-09-22T05:59:00.000Z","updated":"2017-10-20T07:26:47.450Z","comments":true,"path":"2017/09/22/Day21-进程和线程/","link":"","permalink":"http://www.fredsun.me/2017/09/22/Day21-进程和线程/","excerpt":"TODO","text":"TODO 进程application, activity, service, receiver, provider 设置 android:process 进程生命周期 前台进程A. 拥有用户正在交互的 Activity(已调用 onResume)B. 拥有和正在交互的 Activity 绑定的 ServiceC. 拥有正在前台运行的 Service(已调用 startForeground) 可见进程已调用onPause状态下, 但是无法交互的. activity 被 dialog 或者透明activity遮住, 服务进程 后台进程 空进程 上传图片和播放音乐在服务进程启动长时间运行操作的 Activity 最好为其创建服务, 当操作可能比 Activity 更加持久时更需 todohttps://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577617&amp;idx=1&amp;sn=623256a2ff94641036a6c9eea17baab8&amp;scene=1&amp;srcid=0818EecQYYkaSkd5HD8WjDf8#rd http://www.jianshu.com/p/2f8c86ce8ca6","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"}]},{"title":"Day20 - 沉浸式状态栏","slug":"Day20-沉浸式状态栏","date":"2017-09-22T05:58:00.000Z","updated":"2017-10-20T07:23:28.274Z","comments":true,"path":"2017/09/22/Day20-沉浸式状态栏/","link":"","permalink":"http://www.fredsun.me/2017/09/22/Day20-沉浸式状态栏/","excerpt":"在\b尽量少改xml等非代码部分的情况下实现变色龙状态栏","text":"在\b尽量少改xml等非代码部分的情况下实现变色龙状态栏 概念 全屏模式 变色状态栏模式 背景全屏+变色\b状态栏模式 图片全屏+变色状态栏模式 ContentView: activity.findViewById(Window.ID_ANDROID_CONTENT) 获取的 View , 即 setContentView 方法所设置的 View, 实质为 FrameLayout. ContentParent: ContentView 的 parent , 实质为 LinearLayout. ChildView: ContentView 的第一个子 View ,即布局文件中的 layout. 相关函数 该属性可以设置是否为系统 View 预留出空间, 当设置为 true 时,会预留出状态栏的空间.1234567891011121314151617181920212223242526272829303132333435369. ```ContentView```, 实质为 ContentFrameLayout, 但是它的 dispatchFitSystemWindows 重写了 fitsSystemWindows 方法, 所以对其设置 fitsSystemWindows 无效.10. ```ContentParent```, 实质为 FitWindowsLinearLayout, 里面第一个 View 是 ViewStubCompat, 如果主题没有设置 title ,它就不会 inflate .第二个 View 就是 ContentView.11. ```setClipToPadding```: 保持padding, true为保持## 概述* 先看一下四张图* 4.4.4默认![](https://raw.githubusercontent.com/sunxlfred/RES/master/4.4.4_hasStyle.png)* 4.4.4 去掉 ActionBar![](https://raw.githubusercontent.com/sunxlfred/RES/master/4.4.4_noStyle.png)* 5.0 默认![](https://raw.githubusercontent.com/sunxlfred/RES/master/5.0_hasStyle.png)* 5.0去掉 ActionBar![](https://raw.githubusercontent.com/sunxlfred/RES/master/5.0_noStyle.png)* DecorView结构:--DecorView == extends FrameLayout------View (4.4在这自定义个伪状态栏)------LinearLayout----------ViewStub----------FrameLayout--------------FitWindowsLinearLayout(style设置了不带toolbar)------------------ViewStubCompat------------------ContentFrameLayout == ContentView--------------ActionBarOverlayLayout(style设置了带toolbar)------------------ContentFrameLayout == ContentView------------------ActionBarContainer------view(5.0才有的statusbarbackground, 系统级, getChildAt找不到,得finsViewById找)------view(5.0才有的navigationbackground, 系统级, getChildAt找不到,得finsViewById找) 总结一下: 可以看出 DecorView 作为根布局, 持有一个 LinearLayout, * 5.0在LinearLayout下持有四个View, 两个系统级的 View(StatusBar 和 Navigation), 和两个 FrameLayout, 一个是ViewStub, 一个是给了 ContentFraneLayout + ActionBar(当设置不需要 ActionBar 时, 是ViewStubCompat). * 4.4在LinearLayout下只有两个View, 可以推出5.0可以直接```setStatusBarColor```是因为多了这俩view, 那我们只要在 LinearLayout 中插入一个 view 就可以学着5.0的样子, 让ContentFraneLayout下移.### 4.4 以下放弃### 4.4.4 kitcat 谷歌在 Android 的 Window 属性里添加了可以让状态栏和导航栏被穿透(ContentView覆盖StatusBar)的属性 WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUSWindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION 1* 建议使用代码设置(国产ROM有迷之bug) activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#### 全屏模式 1. 给 Window 添加 FLAG_TRANSLUCENT_STATUS 2. 给 ContentView 的子 view 设置 setFitsSystemWindows &gt; FLAG_TRANSLUCENT_STATUS 效果: 自动设置了 SYSTEM_UI_FLAG_LAYOUT_STABLE 和 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 让 ContentView 满屏#### 变色状态栏模式 1. 给 Window 添加 FLAG_TRANSLUCENT_STATUS 2. 给 DecorView 添加一个伪状态栏 3. 给 ContentView 的子 view 全部设置 setFitsSystemWindows#### 背景全屏+变色\b状态栏模式 1. 给 Window 添加 FLAG_TRANSLUCENT_STATUS 2. 给 ContentView 的子 view 全部设置 fitsSystemWindows, 空出StatusBar的高给伪状态栏 3. 给 ContentView 添加一个伪 StatusBar#### 图片全屏+变色状态栏模式1. 给 Window 添加 FLAG_TRANSLUCENT_STATUS2. 给 ContentView 添加一个伪 StatusBar3. 如果是 Imageview 浮在布局上, 即下一个布局也怼上了 StatusBar, 需要手动给后续布局加 topMargin### 5.0 LOLLIPOP 比起 4.4, 不需要 FLAG_TRANSLUCENT_STATUS, 因为谷歌又\b提供了```setStatusBarColor```, 不过默认 StatusBar 的会添加半透明灰条, 所以还得改下 StatusBar 的颜色为透明#### 全屏模式: 1. 给 Window 设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 让 ContentView 怼到顶 2. 给 Window 设置```setStatusBarColor``` 修改透明颜色#### 变色状态栏模式 1. 给 Window 设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 让 ContentView 怼到顶 2. 给 windiw 设置```setStatusBarColor``` 修改指定颜色#### 背景全屏+变色\b状态栏模式 1. 给 Window 设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 让 ContentView 怼到顶 2. 给 Window 设置```setStatusBarColor``` 修改透明颜色 3. 给 ContentView 的子 view 全部设置 fitsSystemWindows, 空出StatusBar的高给伪状态栏 4. 给 ContentView 添加伪 StatusBar#### 图片全屏+变色状态栏模式(3,4步和4.4处理方式一样)1. 给 StatusBar 设置透明2. 给 DecorView 设置 SYSTEM_UI_FLAG_LAYOUT_STABLE 和 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&gt; 是不是很眼熟, 对, 就是FLAG_TRANSLUCENT_STATUS自动附带的设置, 不过5.0 可以直接改 StatusBar 的颜色了, 不需要 TRANSLUCENT_STATUS3. 给 ContentView 添加伪 StatusBar4. 如果是 Imageview 浮在布局上, 即下一个布局也怼上了 StatusBar, 需要手动给后续布局加 topMargin#### 特殊需求:如果一个 StatusBar 可变色的 acitivy, 加入图片全屏 + 变色StatusBar 的 fragment/或 StatusBar 联动的 fragment 也就是当 StatusBar 和 fragment 一体, 建议\b此 fragment 替换为 activity, 虽然可以\b实现, 但是需要页面绘制两遍不说, 二是 StatusBar 是在页面出现后加入的. 如果项目一开始就有这个需求, 那么在全部fragment\b的xml中加状态栏高的view#### fragment中的沉浸式思路:如果需要 StatusBar 和 fragment 一起联动, 需要多两步1. 在fragment的xml中添加一个view(StatusBar_view_height).2. xml中设置StatusBar_view_height的值 0dpv19 - 25dpvw820dp - 64dp 12345678910111213#### 抽屉和activity一个处理思路## 实现&gt;Tips:&gt;自定义Theme 运行时是先找自己版本号对应的styles, 如果没有那就去找无版本号的styles里的. 所以一定要在无版本号的styles里写上自定义Theme, 哪怕里面没有东西, 不然直接崩&gt; **推荐通过代码修改, 单纯的依靠theme也可以, 但是不如代码直观, 也不便于控制**#### 1. theme中需要做的铺垫a. 通过代码里设置 1. 去掉自带actionBar falsefalsetrue 12. 去掉打开时先加载一闪而过的 空白背景+默认StatusBar 的默认背景 true@android:color/transparent 123456789101112#### 2. 代码:[https://github.com/laobie/StatusBarUtil](https://github.com/laobie/StatusBarUtil)## 踩坑* fitsSystemWindows[Extended](http://www.jianshu.com/p/5cc3bd23be7b)到底在哪儿设置 * 在 theme 中设置是对整个 Window, 导致Toast文字内容 上浮, 建议在代码里设置 * 当前布局的最外层和 SystemWindow 接触, 所以给最外层的 view 设置 fitsSystemWindows 才能有效果 * 只有在 StatusBar 为透明或者界面设为全屏时 fitsSystemWindows 才会起作用, 不然 StatusBar的空间轮不到用户处理* WindowTranslucentStatus到底设置true还是false truetrue @android:color/transparent 1* 华为7.0在theme被设置成这样时, StatusBar被摸过后就半透明的挂在头上了, 模拟器则是能直接看到半透明的StatusBar falsetrue @android:color/transparent``` 华为7.0在theme被设置成这样时, StatusBar怎么摸都没事儿, 模拟器也是看不见StatusBar的 TODO flyme/miui可能的bug 参考 Android App 沉浸式状态栏解决方案 知乎 | Android 5.0 如何实现将布局的内容延伸到状态栏? 工具 | 有源代码时直接查看运行后的布局 别人的整理 | 由沉浸式状态栏引发的血案 别人的总结 Android-transulcent-status-bar fitsSystemWindows展开讲讲","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://www.fredsun.me/tags/StatusBar/"}]},{"title":"Day19 - Handler 和 线程间通信","slug":"Day19-Handler与多线程通信","date":"2017-09-18T06:57:00.000Z","updated":"2017-10-20T07:22:32.667Z","comments":true,"path":"2017/09/18/Day19-Handler与多线程通信/","link":"","permalink":"http://www.fredsun.me/2017/09/18/Day19-Handler与多线程通信/","excerpt":"据说Handler是最该读的源码..结果到现在才开始看","text":"据说Handler是最该读的源码..结果到现在才开始看 Handler 的使用创建对象 -&gt; 获取消息对象 -&gt; 发送消息 -&gt; 处理消息 子线程的 run 当主线程执行 123Handler handler = new Handler();//主线程创建Handler...handler.post(Runnable...);//子线程用 Handler 来处理 Runnable 子线程发送消息到主线程 1234567891011121314151617181920private Handler mHandler = new Handler()&#123; @Override public void handlerMessage(Message msg)&#123; switch(msg.what)&#123; case 1: &#125; &#125;&#125;....//子线程Message msg = new Message();//Message msg = mHandler.obtain(1);//Message msg = mHandler.obtainMessage();msg.what = 1;//识别码msg.arg1 = 123;msg.arg2 = 321;msg.obj = \"222\";//msg可以加入objBundle data = new Bundle();msg.setData(data);//msg也可以加入bundlemHandler.sendMessage(msg); Handler的创建Handler.java123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; looper 构造方法looper绑定了当前线程looper.java 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Lopper的真正创建是通过prepare(), 并且一个线程只能创建一个looperlooper.java 1234567891011public static void prepare() &#123; prepare(true);&#125;// 目前quitAllowed应该仅在主线程中被设置成false，自定义线程中均为trueprivate static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; PS: 主线程的 Looper 是在 ActivityThread的main()里创建的1234567public static void main(String[] args) &#123; //··· Looper.prepareMainLooper(); //··· Looper.loop(); //···&#125; MessageQueue 构造函数123456MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125;private native static long nativeInit(); 具体实现在C++12345678作者：SparkInLee链接：http://www.jianshu.com/p/8a344dbd17f0來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。### Looper.loop()loop()主要是一个无限for循环looper.java public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(“Looper.prepare() wasn’t called on this thread.”); } final MessageQueue queue = me.mQueue; //···省略无关代码 for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } //···省略无关代码 msg.target.dispatchMessage(msg); //···省略无关代码 msg.recycleUnchecked(); }}12循环着从MessageQueue.next里拿到消息MessageQueue.java Message next() { // 在Looper#loop()中我们知道返回空消息会退出loop()中的无限循环 // 当调用MessageQueue#quit(boolean)时会调用nativeDestory()销毁MessageQueue，将ptr置为0 final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // 仅在第一次调用时为-1 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } /** * 这个调用跟上面提到native层中Looper的epoll机制相关，用于等待可处理的消息 * nextPollTimeoutMillis &lt; 0 : 进入无限空闲等待，直到有新消息唤醒 * nextPollTimeoutMillis = 0 : 不等待 * nextPollTimeoutMillis &gt; 0 : 进入空闲等待，直到有新消息唤醒或者nextPollTimeoutMillis超时 **/ nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 注：MessageQueue管理的消息是一个消息链表，后续Message中会详细分析 if (msg != null &amp;&amp; msg.target == null) { /** * msg.target为空是一类特殊消息（栅栏消息），用于阻塞所有同步消息，但是对异步消息没有影响， * 后续会详细分析。在这个前提下，当头部是特殊消息时需要往后找是否有异步消息 */ do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { // 找到消息 if (now &lt; msg.when) { // 消息的触发时间在当前时间之后，于是计算出需要等待的时间，准备进入有限空闲等待 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // 找到可处理的消息，更新消息链表数据，返回可处理消息 mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg); return msg; } } else { // 没找到消息，准备进入无限空闲等待 nextPollTimeoutMillis = -1; } // 没有可处理的消息，并且消息队列已经退出，则返回空消息让loop退出 if (mQuitting) { dispose(); return null; } // 当mMessages为空或者mMessages的处理时间在当前时间之后（注意栅栏消息的特殊情况）时， // 并且pendingIdleHandlerCount没有在此处初始化过， // 则设置pendingIdleHandlerCount为IdleHandler的数量，IdleHandler后续详细说明。 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // 无空闲处理器，阻塞队列，进入空闲等待 mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // 调用空闲处理器逻辑，此处代码仅调用一次 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // 设置为0保证空闲处理器代码仅调用一次 pendingIdleHandlerCount = 0; // 在处理空闲处理器的时候可能已经有可处理的消息，因此无需等待 nextPollTimeoutMillis = 0; } }12345### Message的创建1. mHandler.obtainMessage() Handler.java public final Message obtainMessage(){ return Message.obtain(this); } 122. Message.obtain() Message.java public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m; } 1obtain()方法, 回收池sPool就是一个静态Message, obtain 就是取出一个next是null, what是0 的 Message public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } 13. 消息的结构 public int what; // 消息码，带Handler命名空间，因此不同Handler中相同消息码不冲突 public int arg1; // 整数数据 public int arg2; // 整数数据 public Object obj; // 任意对象，当利用Messenger进行跨进程传递时需要继承自Parcelable public Messenger replyTo; // Messenger对象实现跨进程消息传递 public int sendingUid = -1; // 跨进程是标记消息来源的Uid /** * flags可设置消息是否在使用以及是否异步 * FLAG_IN_USE = 1 &lt;&lt; 0，该标记只有在创建或obtain时才会清除，此时方可修改消息的相关数据及进行发送 * FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1，标记该消息为异步消息，不受栅栏消息的影响 **/ /*package*/ int flags; /*package*/ long when; // 消息执行时间，采用SystemClock#uptimeMillis()时间base /*package*/ Bundle data; // 消息的数据 /*package*/ Handler target; // 消息对应的Handler /*package*/ Runnable callback; // 消息对应的回调，具体参看下文中消息处理一节 /*package*/ Message next; // 形成消息链表，以在MessageQueue以及消息回收池中使用 12### Message 放入 MessageQueueHandler 除了 sendMessageAtFrontOfQueue(Message) 外其余均会调用 sendMessageAtTime(Message), 而这两个接口最终调用了 enqueueMessage(MessageQueue, Message, long) private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);}12345&gt; Handler 在构造时可以通过 boolean async 给 Handler 设置是否异步最后调用 enqueueMessageMessageQueue.java // 插入成功返回true，否则返回falseboolean enqueueMessage(Message msg, long when) { // Handler中不允许发送target为空的消息，空消息为特殊消息（栅栏消息） if (msg.target == null) { throw new IllegalArgumentException(“Message must have a target.”); } // 不允许发送状态为使用中的消息 if (msg.isInUse()) { throw new IllegalStateException(msg + “ This message is already in use.”); } synchronized (this) { if (mQuitting) { // 不允许发送消息给已退出的消息队列 IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(&quot;MessageQueue&quot;, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // 消息触发时间最早，直接插在链表头部，如果当前队列阻塞则唤醒消息队列的等待，见MessageQueue#next msg.next = p; mMessages = msg; needWake = mBlocked; } else { // 将消息插入到链表中间，如果链表头是栅栏消息并且该消息是触发时间最早的异步消息则需要进行唤醒 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; prev.next = msg; } if (needWake) { nativeWake(mPtr); } } return true; }12### Message 处理和回收 msg.target.dispatchMessage(msg);msg.recycleUnchecked();12 public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } }12345消息先由消息自身的callback处理, 如果自身回调为空, 就用Handler的回调mCallback处理, 否则用Handler 的 handlerMessage()处理### 栅栏消息target = null; 用于延迟指定时间之后所有的同步消息, 异步照常进行. 发送和移除栅栏消息必须成对, 否则容易导致MessageQueue被挂起发送和移除接口在 Looper.java 中 public int postSyncBarrier() { return mQueue.enqueueSyncBarrier(SystemClock.uptimeMillis());//返回的int 用于移除栅栏信息} public void removeSyncBarrier(int token) { mQueue.removeSyncBarrier(token);}1调用了 MessageQueue 的 enqueueSyncBarrier(long) int enqueueSyncBarrier(long when) { // 创建一个target为空的特殊消息，并根据when插入MessageQueue中合适的位置 // 无需唤醒因为栅栏消息的目的在于阻塞消息的执行 synchronized (this) { final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) { while (p != null &amp;&amp; p.when &lt;= when) { prev = p; p = p.next; } } if (prev != null) { msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } }12返回的 int 用于移除栅栏信息 void removeSyncBarrier(int token) { // 移除token对应的栅栏消息，并在必要的时候进行唤醒 synchronized (this) { Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) { prev = p; p = p.next; } if (p == null) { throw new IllegalStateException(“The specified message queue synchronization “ + &quot; barrier token has not been posted or has already been removed.&quot;); } final boolean needWake; if (prev != null) { prev.next = p.next; needWake = false; } else { mMessages = p.next; needWake = mMessages == null || mMessages.target != null; } p.recycleUnchecked(); if (needWake &amp;&amp; !mQuitting) { nativeWake(mPtr); } } }``` TODO http://www.jianshu.com/p/8a344dbd17f0","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"http://www.fredsun.me/tags/Handler/"},{"name":"线程间通信","slug":"线程间通信","permalink":"http://www.fredsun.me/tags/线程间通信/"}]},{"title":"Day18 - Activity + DecorView","slug":"Day18-Activity+DecorView","date":"2017-09-18T06:57:00.000Z","updated":"2017-12-28T08:20:48.032Z","comments":true,"path":"2017/09/18/Day18-Activity+DecorView/","link":"","permalink":"http://www.fredsun.me/2017/09/18/Day18-Activity+DecorView/","excerpt":"Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。","text":"Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。 Window是一个抽象类, 实现由 PhoneWindow 完成 DecorView在4.4.4-6.0版本 DecorView 是 PhoneWindow 的内部类.本着最小惊异原则5.0比4.4多了12mStatusColorViewmNavigationColorView 从7.0开始, DecorView 从PhoneWindow中抽出来, 并且为了 DecorCaptionView 的关联加入了一系列方法DecorView 继承自 FrameLayout,包含了 statusBar 和 NavigationBar 以及一个自上向下的 mParentView 布局,类似 LinearLayout的结构. WindowManager接口接口 WindowManager 继承自抽象类 ViewManager, 它的实现是 WindowManagerImpl WindowManagerGlobal在 WindowManagerImpl 里创建, 是真正的 window 中 view的 管理类 , 所有DecorView 的 ViewRootImpl 都添加进它维护的数组, 给它管理,以下是 WindowManagerImpl 中的 addView12345public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); //实际是通过WindowManagerGlobal实现的。&#125; ViewRootImpl通过一个map管理View, WindowManagerGlobal 的 addView 最后把视图加进了这, 主要包含 Surface 和 Choreographer 关系简述:在 ActivityThread 的 handleLaunchActivity 中, 干了三件大事 创建了WMG,1234562. ```performLaunchActivity(r, customIntent)``` 中, * ```mInstrumentation.newActivity()```将context传入反射activity名字创建的activity, * ```activity.attach()```, 给 activity 绑上了application的上下文, token, window, 其中 mWindowManager 就是 WindowManagerImpl 类型 * 最后 ```mInstrumentation.callActivityOnCreate```调用onCreate()方法3. 通过```handleResumeActivity()```, 创建windowManager, 调用addView方法, 将 DecorView 加进了windowManagerActivityThread.java final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { ... ViewManager wm = a.getWindowManager(); //获得WindowManager，实际是WindowManagerImpl ... wm.addView(decor, l); //添加视图 ... wm.updateViewLayout(decor, l); //需要刷新的时候会走这里 ... } 123但其实最后都进了WindowManagerGlobal.java. public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... root = new ViewRootImpl(view.getContext(), display); //重要角色登场 view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); //保存起来维护 mParams.add(wparams); ... root.setView(view, wparams, panelParentView); //设置必要属性view是DecorView，panelParentView是PhoneWindow ... } 1234567891011121314151617181920212223242526272829303132333435363738394041424344### DecorView组成 ![](https://raw.githubusercontent.com/sunxlfred/RES/master/DecorView.png) 2. Activity &amp; Window &amp; WMS Window: 定义窗口样式和行为的抽象基类，用于作为顶层的view加到WindowManager中，其实现类是PhoneWindow。每个Window都需要指定一个Type（应用窗口、子窗口、系统窗口）。Activity对应的窗口是应用窗口；PopupWindow，ContextMenu，OptionMenu是常用的子窗口；像Toast和系统警告提示框（如ANR）就是系窗口，还有很多应用的悬浮框也属于系统窗口类型。WindowManager：用来在应用与window之间的管理接口，管理窗口顺序，消息等。WindowManagerService：简称Wms，WindowManagerService管理窗口的创建、更新和删除，显示顺序等，是WindowManager这个管理接口的真正的实现类。它运行在System_server进程，作为服务端，客户端（应用程序）通过IPC调用和它进行交互。Token：这里提到的Token主是指窗口令牌（Window Token），是一种特殊的Binder令牌，Wms用它唯一标识系统中的一个窗口。 ![](https://raw.githubusercontent.com/sunxlfred/RES/master/Activity%26Windows%26WMS.png)Activity有一个PhoneWindow，当我们调用setContentView时，其实最终结果是把我们的DecorView作为子View添加到PhoneWindow的DecorView中。而最终这个DecorView，通过WindowMnagerImpl的addView方法添加到WMS中去的，由WMS负责管理和绘制（真正的绘制在SurfaceFlinger服务中）。### setContentView流程(7.1.1)1. Activity 中Activity.setContentView() 调用了Window.setContentView(), 最后在Window的子类PhoneWindow中实现.2. PhoneWindow.setContentView先判断 mContentParent 是否为空, 第一次加载时肯定为空, 那么跳到 installDocker, 主要干了两件大事, * DecorView mDecor = generateDecor(), 构造 DecorView 并传入 context 第一次创建的话直接 getContext() 拿到上下文,否则通过 DecorContext 的构造方法创建context * ViewGroup mContentParent = generateLayout(mDecor); 创建ViewGroup加载资源 * 最后 通过 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); mContentParent 打入 mDecor * 调用 onContentChanged 提示布局完成3. ActivityThread 的 handleResumeActivity先通过 performResumeActivity 调用 activity 的 performResume 去唤起 mInstrumentation.callActivityOnResume(this);然后DecorView 设置 LayoutParam最后调用 Activity 的 makeVisible 把 DecorView attach到 Window, 在 view 被 attach 到 window 的时候会调用 onAttachedToWindow（）此时可修改 Activity 窗口大小&gt; window 的构造方法里就需要设置 mFeatures, 所以在 PhoneWindow 被创建之前 也就是 setContentView 被调用之前就需要先设置好 mFeatures, 所以 requestWindowFeature 需要在 Window.onContentView 之前设置&gt; WindowManagerService 继承自 IWindowManager.Stub, 这个文件在 FrameWork 源码里找不到, 是 AIDL 在编译时自动生成的### Dialog 为什么不能用别的 context[From](http://www.jianshu.com/p/628ac6b68c15)1. Dialog 是 TYPE_APPLICATION 型的窗口 Dialog 的 show 方法中 public void show() { // 忽略一些代码 mDecor = mWindow.getDecorView(); WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; } try { mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); } finally { } } 1其中 WindowManager.LayoutParams l = mWindow.getAttributes(); 12调用了window的```getAttributes```方法, 返回的是 ```new WindowManager.LayoutParams();```,最后在 WindowManager 中拿的是 public LayoutParams() { super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); type = TYPE_APPLICATION; format = PixelFormat.OPAQUE; } 12345 所以 Dialog 是 TYPE_APPLICATION 类型.2. 系统对于 TYPE_APPLICATION 类型的窗口, 要求必须是 Activity 的 token. ViewRootImpl.setView方法 调用 mWindowSession.addToDisplay, 通过 IWindowSession 发送添加View的请求后, 返回一个值, 根据数值判断, 报 BadTokenException 异常.(C++层面)3. Dialog 在构造时传入的 context Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { // 忽略一些代码 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 123Dialog 在构造时传入的context, 默认是通过 Context.getSystemService 来获取 WindowManager, 如果用Application 或者 Service 的 context 会直接获取 WindowManagerImpl 的实例,这个实例里 token 为 null, 那么在 show 时传过去的也是 null而如果是 Activity, 在handleLaunchActivity 里调用 performLaunchActivity()里调用 activity.attach()时, 传入了token, Activity 又自己重写了 getSystemService 方法, @Override public Object getSystemService(@ServiceName @NonNull String name) { if (getBaseContext() == null) { throw new IllegalStateException( &quot;System services not available to Activities before onCreate()&quot;); } if (WINDOW_SERVICE.equals(name)) { return mWindowManager; } else if (SEARCH_SERVICE.equals(name)) { ensureSearchManager(); return mSearchManager; } return super.getSystemService(name); } 12所以在 dialog 构造方法中的 getSystemService 拿到的是 Activity 的 mWindowManager mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 12可以尝试弹出一个特殊的系统级弹窗来曲线救国manifest 中添加 12dialog.show() 之前添加 alertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt; 有些手机需要打开悬浮窗权限## 卡顿其实就是丢帧, cpu被占用导致无法及时展示下一帧.#### 关于16ms一帧就是一个画面, Android 提出每秒60帧的刷新, 也就是60Hz, 1000/60Hz = 16ms, 相当于60fps.##### 为啥是60fps* 12fps = 翻书* 24fps = 人眼感知连续线性运动* 24fps = 电影焦圈的通常使用频率* 低于30fps无法表达出绚丽的效果, 人眼和大脑之间的协作无法感知超过60fps的画面更新.(Dart据说能拿到120fps)&gt; fps, 系统帧速率, 代表系统一秒内合成的帧数, 由系统硬件和算法决定&gt; Hz, 屏幕刷新率##### 从xml到displayCPU会先把UI组件计算成polygons（多边形）和textures（纹理），然后再交给GPU进行栅格化(Resterization,将向量图转化为机器可以识别的位图)渲染，最后GPU再将数据传送给屏幕，由屏幕进行绘制显示。当然，从CPU到GPU还需要经过OpenGL ES的处理.![](https://raw.githubusercontent.com/sunxlfred/RES/fe79f3c27f667b8121191aef8ccf2f008af79921/resterization.jpg)###### 关于VSYNC(垂直同步)4.1版本加入 接下来要聊聊VSYNC，VSYNC这个概念出来很久了，Vertical Synchronization，就是所谓的“垂直同步”。在Android中这也沿用了这个概念，我们也可以把它理解为“帧同步”。这个用来干嘛的呢，就是为了保证CPU、GPU生成帧的速度和display刷新的速度保持一致，如何利用VSYNC工作的呢，如下图：![](https://raw.githubusercontent.com/sunxlfred/RES/fe79f3c27f667b8121191aef8ccf2f008af79921/vsync.jpg)从上图我们可以知道当上一帧显示结束后，在VSYNC信号刚开始发出时，Android系统就立刻开始了下一帧数据的处理了，这样就不会浪费时间了。图中先显示第0帧，在这16ms显示时间里，CPU和GPU已经开始准备下一帧的数据了，赶在下个VSYNC信号到来时，GPU渲染完成，及时交换数据，display绘制显示完成，不出什么意外的话，每一帧都这么井然有序进行着，那么用户就会体验到那如丝顺滑般的感觉的了，这是多美妙的事情啊！##### 双缓冲机制 其实上面说的就是Android的双缓冲机制，而双缓冲技术一直贯穿这个Android系统。因为实际上帧的数据就是保存在两个缓冲区中，A缓冲用来显示当前帧，那么B缓冲就用来缓存下一帧的数据，这样就可以做到一边显示一边处理下一帧的数据。![](https://raw.githubusercontent.com/sunxlfred/RES/fe79f3c27f667b8121191aef8ccf2f008af79921/doublevsync.jpg)前面的帧用序号表示，但实际上帧数据只保存在A、B两个缓冲区中。当前帧显示缓冲A，Android系统一旦发出VSYN信号时，就会在缓冲B中构建新的帧。当完成后（这里的完成指的是屏幕已经在缓冲B中拿到新一帧的数据，完成绘制），缓冲A的数据就会被清空，继续进行下一帧的绘制，注意，此时缓冲B的数据是不会被清空的，因为当前显示的是缓冲B中帧画面，清空的只是缓冲A的数据。 这样看起来貌似没什么问题，一切都是我们的掌控中。但是，由于某些原因，比如我们应用代码上处理不够好，又或者用户手机后台打开了很多应用，又在听歌又在下载视频什么的，CPU一时间被占用了，导致下一帧绘制的时间超过了16ms，那么问题就来了，这时候用户就不爽了，因为用户很明显感知到了卡顿的出现，也就是所谓的丢帧情况。如下图所示：![](https://raw.githubusercontent.com/sunxlfred/RES/fe79f3c27f667b8121191aef8ccf2f008af79921/JankDoubleVsync.jpg)很好，下面我们来认真分析一下为什么会出现丢帧的情况：Step1. 当Display显示第0帧数据，此时CPU和GPU已经开始渲染第1帧画面，并将数据缓存在缓冲B中；Step2. 但是由于某些原因，就好像上面说的，CPU资源一时间被占用，导致系统处理该帧数据耗时过长或者未能及时处理该帧数据；Step3. 当VSYNC信号来时，display向B缓冲要数据，这下悲催了，因为缓冲B的数据还没准备好，B缓冲区这时候是被锁定的，display无可奈何，只能继续显示之前缓冲A的那一帧，此时缓冲A的数据也不能被清空和交换数据。这种情况被Android开发组命名为“Jank”，就是所谓的“丢帧”，也被称作“废帧”；Step4. 当第1帧数据（即缓冲B数据）准备完成后，它并不会马上被显示，而是要等待下一个VSYNC，Display刷新后，这时用户才看到画面的更新，中间这段时间的时间就白白被浪费掉了。 从上面的分析可以知道，因为缓冲B的超时，掉了链子，导致出现了丢帧的情况。因为一步的延迟，也很有可能导致后面的处理延迟，很可能造成一步慢步步慢啊，像你这样“延误工期”在古代可是大罪啊，分分钟要杀头的哦~~~##### 三倍缓冲机制 出现上面这种情况怎么办，在Android系统里给出了这样的解决办法就是：再加入一个缓冲。这样就出现了三个缓冲，顾名思义，这里说的就是三倍缓冲。好，看下图：![](https://raw.githubusercontent.com/sunxlfred/RES/fe79f3c27f667b8121191aef8ccf2f008af79921/JankTripleVSync.jpg) 当出现B缓冲超时,屏幕显示的还是缓冲A中的那一帧，因为此时缓冲A的数据还在使用，不能及时被交换，所以在下一次VSYNC信号来之前这段时间无任何作为，时间就会白白被浪费。为了避免这种时间浪费，在三倍缓冲机制中，系统这个时候会创建一个缓冲C，用来缓冲下一帧的数据。如上图所示，显示完缓冲B中那一帧后，下一帧就是显示缓冲C中的了。这样虽然还是不能避免会出现卡顿的情况，但是Android系统还是尽力去弥补这种缺陷，最终尽可能给用平滑的动效体验### 卡顿的深入与绘制* HWComposer 硬件抽象模块, 用于产生VSync信号* Choreographer(编舞者), 负责控制视图的绘制, 每个Looper公有一个Choreographer, Looper和线程一对一, 所以Choreographer和线程一对一* SurfaceFlinger, 负责把每个Surface的内容合成缓存, 它和 Surface 通过 Parcelable 共享内存, 是一个系统的服务* Surface, 每个 window 都会有自己的一个 Surface, 每次绘制时将数据绘制到 canvas 索引的内存上. canvas是画笔， 通过调用canvas的API想Surface上绘制图形, 当 ViewRootImpl 调用 onDraw 方法时, 4.0以上就默认开启了硬件加速, * 软绘制, 图形绘制在 Surface 默认的CompatibleCanvas上, 和普通canvas的区别是对Matrix进行了处理, 提供在不同设备商的兼容性 * 硬绘制, 图形绘制在 DisplayListCanvas, DisplayListCanvas 会通过 GPU 使用openGL图形库进行绘制, 更有效率* Vsync offset偏移机制,4.4版本加入, 将一个 HW_VSync 信号拆成 Vsync 和 SF_Vsync,Vsync 被传到Choreographer,用于触发视图树的绘制渲染, SF_Vsync 被传到SurfaceFlinger,用于触发Surface的合成#### ViewRootImpl的一次绘制:1. requestLayout或invalidata出发更新视图请求2. 更新请求传递到ViewRootImpl, ViewRootImpl 向主线程 MessageQueue中加入一个阻塞器, 该阻塞器将会拦截所有同步消息.也就是说此时再通过Handler往主线程MessageQueue传递Message无法被执行, 一下是具体的步骤: ViewRootImpl初始化时, 实现一个Choreographer.FrameCallback, //这个方法只有在ViewRootImpl初始化时才会被调用 private void profileRendering(boolean enabled) { … mRenderProfiler = new Choreographer.FrameCallback() { @Override public void doFrame(long frameTimeNanos) { … scheduleTraversals(); //请求一个Vsync信号，后面还会提到这个方法 mChoreographer.postFrameCallback(mRenderProfiler); //每次回调时，重新将FrameCallback post到Choreographer中 … } }; … mChoreographer.postFrameCallback(mRenderProfiler); //将FrameCallback post到Choreographer中 … } 1scheduleTraversals()方法, 先发出postSyncBarrier到Handler阻塞同步MessageQueue, 接着请求一个Sync信号来刷新界面 void scheduleTraversals() { … mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); //向Choreographer中post一个TraversalRunnable //这又是一个十分重要的对象 … } 1当信号被回调 final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); //开始遍历视图树，这意味着开始绘制一帧内容了 } } ``` 参考简书 | 为什么Dialog不能用Application的ContextCSDN | setContentView源码分析","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"DecorView","slug":"DecorView","permalink":"http://www.fredsun.me/tags/DecorView/"},{"name":"Window","slug":"Window","permalink":"http://www.fredsun.me/tags/Window/"}]},{"title":"Day17 Application 和 Actiity启动过程","slug":"Day17-Application和Activity的onCreate","date":"2017-09-13T14:29:00.000Z","updated":"2017-10-20T07:16:14.723Z","comments":true,"path":"2017/09/13/Day17-Application和Activity的onCreate/","link":"","permalink":"http://www.fredsun.me/2017/09/13/Day17-Application和Activity的onCreate/","excerpt":"初探 Activity 和 Application 启动过程","text":"初探 Activity 和 Application 启动过程 #####tips: xxxNative extends Binder implements Ixxx Instrumentation 仪表, 控制着Application 的 onCreate 和 Activity的全部生命周期(创建的时候都经过它), 这样便于控制Application 和 Activity 创建过程概括起来就是发送Handler给主线程, 主线程调用handle方法去执行的过程 主线程 ActivityThread 的 main() 方法中:a. 先创建了主Looper和主Handler,b. 创建了ActivityThread , 拆成两步, 获取 IBinder 和 加入 application的Binder12345672. 调用 **ActivityManagerNative** 的静态方法它是一个抽象类, 继承自Binder, 实现了 IActivityManager 接口.第1步的 attach() 中通过静态方法 ```ActivityManagerNative.getDefault();``` 通过调用自己的静态单例方法 gDefault 创建出单例的 IActivityManager, 调用静态 asInterface 方法, 将 &quot;activity&quot; 标签的 IBinder 传给 IActivityManager返回到第1步3. 回到 **ApplicationThread** (ActivityThread的内部类)作为 ActivityThread 的内部类, 反而继承自 ApplicationThreadNative, 后者继承 Binder并实现 IApplicationThread, 所以 ApplicationThread 的对象作为第2步 ```IActivityManager.attachApplication(IApplicationThread)``` 的参数也不奇怪了. ApplicationThread 的无参构造方法调用父类的构造方法, 父类的无参构造里只有这一句``` attachInterface(this, descriptor);```, 是父类的父类 Binder 中实现的, 将descriptor交给了Binder, 那么descriptor在哪儿呢, 对, 在接口 IApplicationThread 中 关于descriptor 也只有一句 ```String descriptor = &quot;android.app.IApplicationThread&quot;; 小结一下, 就是 ApplicationThread 的无参构造方法用到了父类的父类的 Binder的 attachInterface(this, descriptor), 而其中的descriptor为它实现的接口 IApplicationThread 的常量字符串”android.app.IApplicationThread”; 回到 ActivityThread此时 thread 就 attach 上了 IActivityManager 和 IApplicationThread 这俩接口的实现, 进入了 Looper 主循环 终于等到了 ActivityManagerServiceAMS处理消息时执行到, 12345678910111213也就是说&gt; ApplicationThread以IApplicationThread的身份到了ActivityManagerService中，经过一系列的操作，最终被调用了自己的bindApplication()方法，发出初始化Applicationd的消息。6. 又回到了 ApplicationThread(ActivityThread的内部类)其中```bindApplication(...)``` 的最后发出了 **H.BIND_APPLICATION** 消息, 交给 外部类ActivityThread 处理.7. 终于回到了 **ActivityThread**其中```handleBindApplication``` 方法中分成三步. * 先反射创建出 Instrumentation 的实例, * 然后调用 LoadApk 类的```makeApplication()```方法创建 Application, * ```makeApplication()``` 中 ContextImpl 创建了 context * ```makeApplication()``` 最后又调用了 Instrumentation 的 ```newApplication```方法, 将 application 反射出来绑定 context * 最后执行 Instrumentation 的 ```callApplicationOnCreate 继续在 ActivityThread 中, Application 初始化完成后, 系统会根据manifest中的配置发送一个intent去启动activity,当收到创建 Activity 的 handler 的消息后, 开始执行handleLaunchActivity,先是 WindowManagerGlobal.initialize(),通过 SystemService 创建了 IWindowManager 在 performLaunchActivity 方法中,Instrumentation 的实例调用 newActivity 方法, 简单粗暴的一句反射就创建了 Activity, 接下来判断是不是isPersistable(), 选择是不是持久化的的调用Activity 的 onCreate(). 最后回到 ActivityThread 继续 handleLaunchActivity, 并调用 handleResumeActivity, 获取window,DecorView, 并让它们Visible, 最后调用activity.makeVisible 纯UML图如下以及 大神 的流程图 参考简书 | 3分钟看懂Activity启动流程","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://www.fredsun.me/tags/Activity/"},{"name":"Application","slug":"Application","permalink":"http://www.fredsun.me/tags/Application/"}]},{"title":"Day16 -6大原则和23种设计模式","slug":"Day16-6大原则和23种设计模式","date":"2017-09-12T05:59:00.000Z","updated":"2017-10-20T07:12:53.824Z","comments":true,"path":"2017/09/12/Day16-6大原则和23种设计模式/","link":"","permalink":"http://www.fredsun.me/2017/09/12/Day16-6大原则和23种设计模式/","excerpt":"从 ActivityManagerNative 和 ActivityManagerProxy 发现的代理模式展开记录下","text":"从 ActivityManagerNative 和 ActivityManagerProxy 发现的代理模式展开记录下 面向对象的六大原则 单一职责原则 开闭原则, 对于扩展开放, 对于修改封闭 里氏替换原则, 所有引用基类的地方必须能透明地使用其子类对象(抽象类) 依赖倒置原则, 解耦(高层次的模块不依赖于低层次的模块实现) 接口隔离原则, 拆分接口 迪米特原则, 一个对象对其他对象应该有最少的了解 设计模式 代理模式 单例模式 Builder模式 原型模式 工厂模式 抽象工厂模式 策略模式 状态模式 责任链模式 解释器模式 命令模式 观察者模式 备忘录模式 迭代器模式 模板方法模式 访问者模式 中介者模式 组合模式 适配器模式 装饰模式 享元模式 外观模式 桥接模式 MVC, MVP, MPPM 代理模式代理模式就是给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。就是一个人或者一个机构代替另一个人或者另一个机构去采取一些行动，以控制对这个对象的访问。 所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。 代理模式分为8种, ActivityManagerNative 用到的是 Remote 代理, 外界通过IActivityManager 的实现, 而 ActivityManagerNative 和 ActivityManagerProxy 都在 ActivityManagerNative.java文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445```javapublic abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); &#125; return am; &#125; &#125;;&#125;class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125;&#125; 单例模式Builder模式类似AlertDialog.builder1234567891011121314151617181920212223242526public class MyBuilder&#123; private int id; private String num; public MyData build()&#123; MyData d=new MyData(); d.setId(id); d.setNum(num); return t; &#125; public MyBuilder setId(int id)&#123; this.id=id; return this; &#125; public MyBuilder setNum(String num)&#123; this.num=num; return this; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; MyData d=new MyBuilder().setId(10).setNum(\"hc\").build(); &#125;&#125; 工厂模式根据传入的参数决定产生的是什么对象1234567891011121314public Object getSystemService(String name) &#123; if (getBaseContext() == null) &#123; throw new IllegalStateException(\"System services not available to Activities before onCreate()\"); &#125; //........ if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; &#125; else if (SEARCH_SERVICE.equals(name)) &#123; ensureSearchManager(); return mSearchManager; &#125; //....... return super.getSystemService(name); &#125; 抽象工厂模式12345678public class BaseService extends Service&#123; @Nullable @Override public IBinder onBind(Intent intent)&#123; return new Binder(); &#125;&#125; 策略模式属性动画的插值器, 可以从一个方法中实现很多种 状态模式wifi 行为由状态决定, 不同状态启动不同方法 责任链模式点击事件的传递 解释器模式AndroidManifest.xml 中对, 的解析 命令模式事件传递中, 每次的按键事件都会被封装成 NotifyKeyArgs 对象, 通过 InputDispatcher 封装具体的事件操作. 观察者模式ListView 的 Adapter 的notifyDataSetChange() 备忘录模式Activity 的 onSaveInstanceState 和 onRestoreInstanceState 迭代器模式Iterator 类, SQLiteDataBase 的 query 方法, 返回的 cursor 对象, 通过如下方式去遍历1234cursor.moveToFirst();do&#123;//cursor.getXXX(int);&#125;while(cursor.moveToNext); 模板方法模式Activity 的 onCreate, onStart方法 访问者模式编译器的注解, APT(Annotation Processing Tools), ButterKnife, Dagger, Retrofit 中介者模式Binder系统启动时, 各种系统服务会向 ServiceManager 提交注册, 即 ServiceManager 持有各种系统服务的引用, 当我们需要获取系统的 Service 时, 比如 ActivityManager, WindowManager等(它们都是 Binder), 首先是向 ServiceManager 查询指定标志符对应的 Binder, 再由 ServiceManager 返回 Binder 的引用, 并且客户端和服务端之间的通信是通过 Binder 驱动来实现, 这里的ServieManager 和 Binder 驱动就是中介者. 组合模式View, ViewGroup 适配器模式把一个类的接口变成客户端所期待的另一个类的接口, 从而使得原本接口不匹配而无法在一起工作的两个类能够在一起工作ListView 的 adapter: ListView 只关心 它的每个ItemView, 不关心ItemView具体显示什么. 数据源和 ListView 之间也没有什么关系 通过适配器提供给ListView getView()方法, 每次 ListView 只需要提供位置信息给getView(), 然后 getView 根据位置信息向数据源获取对应的数据, 根据数据返回不同的View. 装饰模式通过内部类, 内部类的实例既有外部类的实例, 还有自己在内部类添加的方法ContextWrapper 内部有个 Context的引用, 并且 ContextWrapper 对 Context的每个方法都有实现, 在实现中调用的就是mContext的方法 享元模式池来重用对象, 避免频繁创建对象, 常量池, 线程池.Message.obtain()就是从消息池中取出可重复使用的信息, 避免产生大量 Message 对象. 外观模式一个子系统的外部与内部的通信必须通过一个统一的对象进行.Context, Android的很多操作, 比如 StartActvity, BindService(), sendBroadCast都通过 Context 实现. 桥接模式将抽象和实现部分分离, 使它们能独立的进行变化.比如 View ,可以将其写成ButtonView, TextView 进行描述上的变化, 也可以将其作为 DisPlay, Canvas 的操作对象. MVC, MVP MVVMMVCModel: 下载下来的数据View: ViewController: Activity MVPModel:View:Presenter: MVVMModel: 数据View: ViewViewModel: ViewHolderRecyclerView 中的 ViewHolder 就是, 通过ViewHodler, 不用每次都写 findViewById. 参考 简书 | 从Android代码中来记忆23种设计模式","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.fredsun.me/tags/设计模式/"}]},{"title":"Day15 - Activity 动画","slug":"Day15-View","date":"2017-09-11T15:18:00.000Z","updated":"2017-10-20T07:10:06.378Z","comments":true,"path":"2017/09/11/Day15-View/","link":"","permalink":"http://www.fredsun.me/2017/09/11/Day15-View/","excerpt":"View的属性和几个方法","text":"View的属性和几个方法 View FromView 分类单一视图 如 TextView视图组 如 ViewGroup, LinearLayout ViewGroup 继承自 View View 构造函数分为两大类123456789101112131415161718192021222324//如果是在 Java 代码里面 new 的private CarsonView(Context context)&#123; super(context);&#125;// 如果是在.xml里声明的// 自定义属性由 attrs 传递private CarsonView(Context context, Attribute attrs)&#123; super(context, attrs);&#125;// 在第二种情况下,// 当 view 包含 style 属性private CarsonView(Context context, Attribute attrs, int defStyleAttr)&#123; super(context, attrs, defStyleAttr);&#125;// API21后// 在第二种情况下,// 当 view 包含 style 属性时private CarsonView(Context context, Attribute attrs, int defStyleAttr, int defStyleRes)&#123; super(context, attrs, defStyleAttr, defStyleRes);&#125; attrs XML中的属性defStyleAttr 应用到 View 的默认风格(定义在主题中)defStyleRes 如果没有使用 defStyleAttr , 应用到View的默认风格 View 视图结构 无论是 measure, layout 还是 draw, 永远都是从根View开始测量/计算， 最终确定整个View的属性 View 坐标系top, left, right, bottom 属性都是相对父容器的 View 获取位置 view.getLeft() 获取view左上角到父容器左侧的距离 MotionEvent中触摸点相对于其所在坐标系中的距离 12e.getX()e.getY() 触摸点相对于屏幕的距离 12e.getRawX();e.getRawY(); Android 中角度和弧度 角度的增大方向为顺时针 自定义View From1. Measure1.1 方法 measure()final 类型, 无法重写, 最终会调用 onMeasure() onMeasure()自己重写 setMeasureDimension()存储测量后的宽高 setMeasuredDimensionRaw()设置 mMeasuredWidth 和 mMeasuredHeight getDefaultSize()根据测量规格的模式, 给出测量值 1.2 测量过程一个view的值由 自身的LayoutParams 和 父布局的 MeasureSpec 决定 它没有父布局, 由自身的 LayoutParams 和 窗口尺寸决定)```12345678910111213141516171819202122![](https://raw.githubusercontent.com/sunxlfred/RES/05931a7450141456cf58bea60662d88195c6b877/view-measurespec.png)### 2. Layout#### 2.1方法1. layout();确定 View 本身的位置2. onLayout;单一 View 空实现,ViewGroup 调用 onLayout 遍历子View 并调用子View layout()确定自身子View 的位置ViewGroup中 因为子view的确定位置与布局有关, 需重写#### 2.2 layout 过程![](https://raw.githubusercontent.com/sunxlfred/RES/cf38ad4f4254bf13446dff6f9bdb3235223090f8/onLayout.png)#### 2.3 getWidth/getHeight 和 getMeasureWidth/getMeasureHeight 差别1. 定义* getWidth/getHeight view最终的宽高* getMeasureWidth/getMeasureHeight view的测量的宽高2. 代码 // View的测量的宽 / 高： public final int getMeasuredWidth() { return mMeasuredWidth &amp; MEASURED_SIZE_MASK; // measure 过程中返回的 mMeasuredWidth } public final int getMeasuredHeight() { return mMeasuredHeight &amp; MEASURED_SIZE_MASK; // measure 过程中返回的 mMeasuredHeight } // View最终的宽 / 高 public final int getWidth() { return mRight - mLeft; // View最终的宽 = 子View的右边界 - 子view的左边界。 } public final int getHeight() { return mBottom - mTop; // View最终的高 = 子View的下边界 - 子view的上边界。 } 12345678910113. 时机* getMeasureWidth/getMeasureHeight在 measure 的 setMeasureDimension()中setMeasureDimensionRaw 赋值, 在 onLayout 用它来获取宽高* getWidth/getHeight在 layout 的 layout()中赋值, 可以用于除 onLayout() 之外的地方获取宽高4. 结论在onLayout中用getMeasureWidth/Height(), 在其他地方用getWidth/Height()一般情况下两者的值是永远相等的, ```与View是否超出屏幕无关```,除非人为设置 通过重写View的layout（）强行设置， @Override public void layout( int l , int t, int r , int b){ // 改变传入的顶点位置参数 super.layout(l，t，r+100，b+100) // 如此一来，在任何情况下，getWidth() （ getHeight()）获得的宽 / 高总是比getMeasuredWidth() （getMeasuredHeight()）获取的宽 （高）大100px // View的最终宽 / 高总是比测量宽 / 高大100px } 1234567891011121314151617181920212223### 3. draw#### 3.1 方法* draw()绘制自身 1. drawBackground() 绘制自身View的背景 2. onDraw() 绘制自身View的内容, **自定义View中必须且只需要重写onDraw** 3. dispatchDraw() 单一View空实现 4. onDrawScrollBar()绘制装饰##### 3.2 draw 过程![](https://raw.githubusercontent.com/sunxlfred/RES/914931d5ac4c63bb4e2a7ba6907a2bb3013ecdcf/onDraw.png)### setContentViewActivity 在 android 中的根布局被分为 标题栏 + ContentView(外面包着 FrameLayout), 所以我们平时操作的都是 ContentView, 布局都是 setContentView, 而不是setView ![](https://raw.githubusercontent.com/sunxlfred/RES/6a8cc51ce70b4b09472c8102479c962e18d0a592/view.png)因为外部有父布局FrameLayout, 所以属性 layout_width 和 layout_height 里的layout都是有的, 设置能起作用的而如果我们通过纯代码方式创建布局, 如下: LinearLayout mainLayout = (LinearLayout)findViewById(R.layout.main_layout);LayoutInflater layoutInflater = LayoutInflater.from(this);View buttonView = layoutInflater.inflate(R.layout.button_layout, null);mainLayout.addView(buttonView);1234567再给button_layout添加 layout_width 和 layout_height 属性```xmlns&lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;80dp&quot; android:text=&quot;Button&quot; &gt; &lt;/Button&gt; 会发现无效, 因为button_layout没有父布局, 所以套一个布局就能让属性生效了1234567891011&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;Button android:layout_width=&quot;300dp&quot; android:layout_height=&quot;80dp&quot; android:text=&quot;Button&quot; &gt; &lt;/Button&gt; &lt;/RelativeLayout&gt; 参考Android LayoutInflater原理分析，带你一步步深入了解View(一)深入理解Android View的构造函数自定义View Measure过程 - 最易懂的自定义View原理系列（2）自定义View Layout过程 - 最易懂的自定义View原理系列（3）自定义View Draw过程- 最易懂的自定义View原理系列（4）Android开发之getMeasuredWidth和getWidth区别从源码分析","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.fredsun.me/tags/View/"}]},{"title":"","slug":"Day28-动画","date":"2017-09-07T08:03:27.000Z","updated":"2017-09-08T03:45:22.000Z","comments":true,"path":"2017/09/07/Day28-动画/","link":"","permalink":"http://www.fredsun.me/2017/09/07/Day28-动画/","excerpt":"","text":"动画可以拆分为 Animation, Transition, 以及Material 中的部分效果 #Animation 属性动画 PropertyAnimation (基本都是属性动画)补间动画 ViewAnimation 逐帧动画 FrameAnimation也叫做DrawAnmation 补间动画 TweenAnimation1. 分类 平移动画(Translate) 缩放动画(Scale) 旋转动画(Rotate) 透明度动画(Alpha) 组合动画(set) 2. 属性123456789101112131415161718192021222324252627282930313233343536373839404142-set |-android:interpolator -&gt; 插值器，影响动画的速度 |-默认值 -&gt; @android:anim/accelerate_decelerate_interpolator |-android:shareInterpolator -&gt; 集合所有动画是否使用同一插值器 |-android:fillAfter -&gt; 动画结束后View是否停留在结束的位置 |-android:startOffset -&gt; 动画多少秒之后执行 |-android:repeatMode -&gt; 重复的模式,默认为restart,即重头开始重新运行,reverse即从结束开始向前重新运行-TranslateAnimation -&gt; 移动View |-&lt;translate&gt; |-android:fillAfter -&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromXDelta -&gt; 表示 x 的起始值 |-android:toXDelta -&gt; 表示 x 的结束值 |-android:fromYDelta -&gt; 表示 y 的起始值 |-android:toYDelta -&gt; 表示 y 的结束值-scaleAnimation -&gt; 放大或者缩小View |-&lt;scale&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromXScale -&gt; 表示水平方向缩放的起始值 |-android:fromYScale -&gt; 表示竖直方向缩放的起始值 |-android:pivotX -&gt; 表示缩放中心点的 X 坐标 |-android:pivotY -&gt; 表示缩放中心点的 Y 坐标 |-android:toXScale -&gt; 表示水平方向缩放的结束值 |-android:toYScale -&gt; 表示竖直方向缩放的结束值-RotateAnimation -&gt; 旋转View |-&lt;rotate&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromDegrees -&gt; 旋转开始的角度 |-android:toDegrees -&gt; 旋转结束的角度 |-android:pivotX -&gt; 旋转中心点的 X 坐标 |-android:pivotY -&gt; 旋转中心点的 Y 坐标-AlphaAnimation -&gt; 改变View的透明度 |-&lt;alpha&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromAlpha -&gt; 透明度的起始值 |-android:toAlpha -&gt; 透明度的结束值-自定义View动画 -&gt; (不会,待实践中学习)作者：Shaun白一辰链接：http://www.jianshu.com/p/b7aa2a4a9787來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 3.缺点: 只能对View操作, 如果需要对View中的某个对象, 无法操作 如果需要改变View的背景色, 没提供方法所以无法实现了 致命缺点是只是改变了显示效果, 属性没变, 如果一个button通过补间动画改变位置, 在新的位置点击没有点击效果. Transition4.4加入, 多用于5.0的Activity动画 Material 触摸反馈(波纹效果) xml中对view添加 1234//按钮内波纹android:background=&quot;?android:attr/selectableItemBackground&quot;//超出按钮的波纹android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot; 修改波纹颜色,主题里设置1234 &gt; 也可直接使用RippleDrawable* 使用揭露效果 iv_click.post(new Runnable() { @Override public void run() { Animator animator = ViewAnimationUtils.createCircularReveal( iv_click, iv_click.getWidth() / 2, iv_click.getHeight() / 2, iv_click.getWidth(), 0 ); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.setDuration(2000); animator.start(); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); iv_click.setVisibility(View.GONE); } }); } });``` 报错: java.lang.IllegalStateException: Cannot start this animator on a detached view!因为view开启动画效果需要view.post(new Thread), 不能直接在onCreate里进行","categories":[],"tags":[]},{"title":"Day14 - Activity 动画","slug":"Day14-Activity动画","date":"2017-09-07T08:03:00.000Z","updated":"2017-10-20T07:00:51.499Z","comments":true,"path":"2017/09/07/Day14-Activity动画/","link":"","permalink":"http://www.fredsun.me/2017/09/07/Day14-Activity动画/","excerpt":"Activity上了动画后黑屏","text":"Activity上了动画后黑屏 Activity动画(Transition)分为两种, overridePendingTransition ActivityOption overridePendingTransition(enterAnim, exitAnim);紧跟在 startActivity()／finish（）之后 黑屏当使用 overridePendingTransition(R.anim.right_to_current,0); 容易黑屏解决： overridePendingTransition(R.anim.activity_open,R.anim.activity_stay);将activity的退出设置透明度从 1 到 1. activity_stay.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;alpha android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;1&quot; android:duration=&quot;300&quot; /&gt;&lt;/set&gt; ActivityOption 在theme添加 123&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 通过 startActivity(intent, bundle); 的 bundle 设置 1234ActivityOptions options = ActivityOptions.makeScaleUpAnimation(view, 0, 0, view.getWidth(), view.getHeight());//ActivityOptionsCompat optionCompat = ActivityOptionsCompat.makeScaleUpAnimation(view,0,0,view.getWidth(),view.getHeight());intent.putExtra(\"myserializabledata\", persion);startActivity(intent, optionCompat.toBundle()); 五种静态方法创建动画 makeCustomAnimation(Context context, int enterResId, int exitResId)效果: 与普通的overridePendingTransition差不多 12345ActivityOptions options = ActivityOptions.makeCustomAnimation( MainActivity.this, //传入的activity的上下文 android.R.anim.slide_in_left, //A Activity退出的效果 android.R.anim.slide_out_right //B Activity进入的效果 ); makeScaleUpAnimation(View source,int startX, int startY, int startWidth, int startHeight)效果: 看到 B Activity 从相对于指定控件原点的指定位置, 按照指定大小不断扩大B Activity 1234567ActivityOptions options = ActivityOptions.makeScaleUpAnimation( iv_click, //从A控件 0, //从A控件的宽度为0 0, //从A控件的高度为0 iv_click.getWidth(), //打开的Activity最开始是多宽 iv_click.getHeight() //打开的Activity最开始是多高 ); makeThumbnailScaleUpAnimation(View source,Bitmap thumbnail, int startX, int startY)效果: 和 2 相似, 只是放大的过程是指定的View放大, 最后才换成显示 B Activity 123456ActivityOptions options = ActivityOptions.makeThumbnailScaleUpAnimation( iv_click, bitmap, 0, iv_click.getHeight() ); makeSceneTransitionAnimation(Activity activity, View sharedElement, String sharedElementName)效果: 用于单个元素共享 回退的时候如果还需要效果, 用 finishAfterTransition(); 替代finish(); 目标 Activity 可以是 SingleTask 但是不能指定 taskAffinity, 否则点击时闪屏, 但锁屏后再开, 却显示已经跳转到了B Activity. 手机版本需要 Lolipop/5.0以上 控件需要在Activity布局内,不能 listview 再 addHeadView Link Theme 需要设置为android:Theme.Material 或者AppCompat 注意: 报错 need to use a Theme.AppCompat theme (or descendant) with this activity.```如果你的Theme原来是 AppCompatActivity, 此时需要修改为Activity, 或者 如果有v4包的Fragment, 那就得设置成 FragmentActivity [Link](http://blog.csdn.net/ouyang_peng/article/details/51334761)12 ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation( MainActivity.this, iv_click, getString(R.string.MainToSecond) ); 12345. makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;… sharedElements)效果: 用于多个元素共享 * Pair里的view别强转成TextView, ImageView ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation( MainActivity.this, Pair.create(findViewById(R.id.iv_click), getString(R.string.MainToSecond)), //这里是View, 不能是ImageView, TextView之类的 Pair.create(findViewById(R.id.tv_click), getString(R.string.MainToSecondText))); startActivity(intent,options.toBundle()); 12345678910111213### 动画效果提供了5种.* changeBounds - 改变目标视图的布局边界* changeClipBounds - 裁剪目标视图边界* changeTransform - 改变目标视图的缩放比例和旋转角度* changeImageTransform - 改变目标图片的大小和缩放比例* changeScroll -#### 添加方法#####1. style 设置右键res, new -&gt; Android resource directory -&gt; transition&gt; 新建的文件根标记需要设置为&lt;transitionSet&gt;, 如果是&lt;transitionManager&gt; 会导致 ``` &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;@transition/change_bounds&lt;/item&gt;```不能识别 //是否允许过渡动画 true//A Activity 动画效果是否显示 true//B Activity 动画效果是否显示 true//指定普通进入动画 @android:transition/slide_bottom//指定普通退出动画 @android:transition/slide_bottom//自定义进入的transition动画 @transition/change_bounds//自定义退出的transition动画 @transition/change_bounds1234567#####2.代码设置```java// 允许使用transitions getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); // 设置一个exit transition getWindow().setExitTransition(new Explode());//new Slide() new Fade() Window.setEnterTransition()：设置进入动画Window.setExitTransition()：设置退出效果Window.setSharedElementEnterTransition()：设置共享元素的进入动画Window.setSharedElementExitTransition()：设置共享元素的退出动画 兼容低版本(不挂，还是没效果) 注意: Pair类也要是V4包的1234ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation( MainActivity.this, android.support.v4.util.Pair.create(findViewById(R.id.iv_click), getString(R.string.MainToSecond)), android.support.v4.util.Pair.create(findViewById(R.id.tv_click), getString(R.string.MainToSecondText))); 参考CSDN | 关于activity转场动画makeSceneTransitionAnimation没效果的问题的解决办法Google | 定制操作行为转换 CSDN | 你所不知道的Activity转场动画——ActivityOptionsym—— Android 5.0学习之Activity过渡动画","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://www.fredsun.me/tags/动画/"}]},{"title":"Day13 - 进程间通信","slug":"Day13-进程间通信IPC","date":"2017-09-05T09:53:00.000Z","updated":"2017-10-20T06:58:36.500Z","comments":true,"path":"2017/09/05/Day13-进程间通信IPC/","link":"","permalink":"http://www.fredsun.me/2017/09/05/Day13-进程间通信IPC/","excerpt":"Serializable 和 Parcelable到底谁快, 各自是如何实现的, Intent能传多少数据","text":"Serializable 和 Parcelable到底谁快, 各自是如何实现的, Intent能传多少数据 进程进程有自己的内存地址, 一个进程中的1000地址可能在另一个进程中是10000, java的引用本质上还是内存地址, 如果要传递一个类的实例, 还需要传递方法等等, 方法是独立与类对象存在的, 所以到另一个进程中去引用同一个方法就错了, 还是因为独立内存地址的原因.Android中Activity之间并不能保证两个Activity在同一个进程中, 比如一个APP调用系统打电话功能, 就是两个进程, 不同进程是不共享资源的, 所以需要进程间通信 Binder From在 Android 开机过程中, Android 会初始化系统的各种service, 并将这些service 向 ServiceManager 注册, 客户端想要得到具体的 Service , 直接向 ServiceManager 要即可.客户端先向 ServiceManager 查询想要得到具体的 Service 引用, 然后通过这个引用向具体的服务端发送请求, 服务端执行完成就返回.图来自[http://www.jianshu.com/p/04a034cbbc27] 服务端跨进程的类都要继承Binder类, 我们所持有的Binder引用, 并不是实际真实的远程Binder对象, 我们的引用在 Binder 驱动的时候还要做一次映射.设备驱动跟我们引用对象找到对应的远程进程. 客户端要调用远程对象函数时, 只需把数据写入Parcel, 在调用所持有的Binder引用的transact函数执行过程中会把参数, 标志符(标记远程对象及其函数)等数据放到Client的共享内存, Binder驱动会从Client的共享内存中, 并通过远程进程执行```onTransact()```函数, 远程进程 Binder 对象执行完成后, 将得到的写入自己的共享内存, Binder 驱动再将远程进程的共享内存数据拷贝到客户端的共享内存, 并唤醒客户端的进程.1234所以别在主线程去调用远程函数, 防止 ANR![](https://raw.githubusercontent.com/sunxlfred/RES/da524229240c54ab812fa2edb10c38e9a6796f4c/clientRequestServerByBinder.png) //获取WindowManager服务引用 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);//布局参数layoutParams相关设置略… View view= LayoutInflater.from(getApplication()).inflate(R.layout.activity_main, null);//添加view wm.addView(view, img.getLayoutParams());123456789&gt;getSystemService(getApplication().WINDOW_SERVICE);函数内部原理就是向ServiceManager查询标识符为getApplication().WINDOW_SERVICE的远程对象的引用。即WindowManager对象的引用，这个引用的真正实现是WindowManager的某个代理。得到这个引用后，在调用addView时，真正的实现是在代理里面，代理把参数打包到Parcel对象中，然后调用transact函数（该函数继承自Binder），再触发Binder驱动的一系列调用过程作者：huachao1001链接：http://www.jianshu.com/p/04a034cbbc27來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。### getSystemService 时发生了什么 [From](http://blog.csdn.net/xyh269/article/details/52789737)1. getSystemService调用的到 ContextWrapper 的 getSystemService: @Overridepublic Object getSystemService(String name) { return mBase.getSystemService(name);}122. mBase 为Context的实现类 ContextImpl, 它的getSystemService: @Overridepublic Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name);}123. SystemServiceRegistry 的 getSystemService: /** Gets a system service from a given context.*/public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;}14. 来看 SYSTEM_SERVICE_FETCHERS 和 ServiceFetcher 都是啥, 一个是 HashMap, 一个是接口 private static final HashMap","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"IPC进程间通信","slug":"IPC进程间通信","permalink":"http://www.fredsun.me/tags/IPC进程间通信/"},{"name":"Binder","slug":"Binder","permalink":"http://www.fredsun.me/tags/Binder/"},{"name":"Serializable & Parcelable","slug":"Serializable-Parcelable","permalink":"http://www.fredsun.me/tags/Serializable-Parcelable/"},{"name":"Intent","slug":"Intent","permalink":"http://www.fredsun.me/tags/Intent/"}]},{"title":"Day12 - Java","slug":"Day12-Java","date":"2017-09-04T15:50:00.000Z","updated":"2017-10-20T06:53:04.437Z","comments":true,"path":"2017/09/04/Day12-Java/","link":"","permalink":"http://www.fredsun.me/2017/09/04/Day12-Java/","excerpt":"值传递和引用传递, String可再次赋值? Lambda","text":"值传递和引用传递, String可再次赋值? Lambda 值传递和引用传递 值传递是值的拷贝, 引用传递是引用的拷贝1234567891011121314public static void main(String[] args) &#123; String x = new String(\"goeasyway\"); change(x); System.out.println(x);&#125;public static void change(String x) &#123; x = \"even\";&#125;作者：goeasyway链接：http://www.jianshu.com/p/c0c5e0540928來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 String 类型是引用类型, new String 创建了数据在堆, 把这堆数据的首地址存在了栈change(x) 方法传递参数时, 将首地址传进来x = “even”; 对 String 改变, 但是无法被记录, 因为源码里 String 是 final 类型:12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; 而如果是 int a = 2 来进行 change, 也无法改变, 但是因为其他原因:基本类型在方法传递时是值传递, 结果不会影响到原来的值;如果希望字符串可以改变, 那么使用StringBuilder就可以了, 因为引用类型是首地址传递, 结果会影响到原来的值. 字节Byte, 位bit1字节(Byte) = 8位(bit)bit是数据存储的最小单位,也叫做比特文字: ASCII码中一个英文字母占一个字节, 一个中文占两个字节标点: 英文标点占一个字节, 中文标点占两个字节1KB = 1024B(Byte)CPU的位指CPU一次能处理的最大位数, 比如32位计算机的CPU一次最多能处理32位数据 基本数据类型的取值范围boolean 8bitchar 16bitint 32bitlong 64bitfloat 32bitdouble 64bit String不是基本类型, 但是希望把它作为基本类型来用(基本类型传值, 对象传引用)简单的说是希望让String能像基本类型一样传递值(不会因为引用指向了同一个内存地址而在传递的过程中改变值.) 特点: String 的内容不会变. 原因: 123456//JDK源码中:public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; //String 的本质是final的数组 &#125; 单靠 final 修饰 String 只是让 String 不可继承, 而数组 value 被final修饰, 也只是防止数组的引用地址被改, 如果使用 123456final int[] value = &#123;1,2,3,&#125;;value[2]=100; //数组被改成&#123;1,2,100&#125;或者final int[] value = &#123;1,2,3,&#125;;Array.set(value, 2,100); //数组还是被改成&#123;1,2,100&#125; 所以还有个 private 让 value[] 只允许自己修改, 并在写 String 时不暴露出操作 value[]的方法. 静态内部类静态内部类和非静态内部类静态内部类是个独立的类, 比如A,B两个类, B有点特殊, 虽然独立存在, 只可以被A使用. 这时候, 如果把B并入A里, 复杂度提高, 搞得A违反了单一职责, 又可能被其他类(同一个包下的C)依赖, 不符合设计的本意, 所以不如将其变成A.B, 等于加个注释, 告诉其他类别使用B了, 它只跟A玩.非静态内部类才是真正的内部类, 持有外部类的引用.静态内部类英文名static nested classes(静态嵌套类) Lambda gralde中替换编译器为jack 123defualtConfig&#123; useJack(true)&#125; 引用Java8 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125; 范例:123btnHandler.setOnClickListener(v -&gt; &#123; Log.i(&quot;a&quot;,&quot;a&quot;);&#125;); 泛型 参考自Link extends T>```：是指 “上界通配符（Upper Bounds Wildcards）”123456* ```&lt;? super T&gt;```：是指 “下界通配符（Lower Bounds Wildcards）”1. 为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。我们有Fruit类，和它的派生类Apple类 ```java class Fruit &#123;&#125; class Apple extends Fruit &#123;&#125; 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 123456class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t; public void set(T t)&#123;item=t; public T get()&#123;return item;&#125; 现在定义一个盘子, 逻辑上”水果盘子”可以装水果, 也可以装苹果 p 123456789 但实际上Java编译器不允许这个操作, error: incompatible types: Plate&lt;Apple&gt; cannotbe converted to Plate&lt;Fruit&gt; 编译器的逻辑: 苹果 IS-A 水果 装苹果的盘子 NOT-IS-A 装水果的盘子 所以就算容器里装的东西有继承关系, 但容器之间没有继承关系, 所以我们不可以把Plate&lt;Apple&gt;的引用传递给Plate&lt;Fruit&gt; 而通配符就是用来让水果盘子和苹果盘子之间发生关系2. 上界通配符 Plate&lt;? extends Fruit&gt; 1234一个能放水果以及一切水果派生类的盘子.它和```Plate&lt;Apple&gt;```的区别就是```Plate&lt;? extends Fruit&gt;``` 是 ```Plate&lt;Apple&gt;``` 和 ```Plate&lt;Fruit&gt;```的基类直接好处是可以用苹果盘子给水果盘子赋值了```Plate&lt;? extends Fruit&gt; = Plate&lt;Apple&gt;(new Apple()); 如果把Fruit和Apple的例子扩展一下, 123456789101112class Food&#123;&#125;;class Fruit extends Food&#123;&#125;class Meat extends Food&#123;&#125;class Apple extends Fruit&#123;&#125;class Apple extends Fruit&#123;&#125;class Pork extends Meat&#123;&#125;class Beef extends Meat&#123;&#125;class RedApple extends Apple&#123;&#125;class GreenApple extends Apple&#123;&#125; 上界通配符的范围是 下界通配符 1Plate&lt;? super Fruit&gt; 一个能放水果以及一切水果基类的盘子, super Fruit>``` 是 ```Plate```的基类, 但不是 ```Plate``` 的基类,1234567 下界通配符的范围是 ![](https://raw.githubusercontent.com/sunxlfred/RES/e2954ad50c818ed46d3acf64ab0cd51ba64b1f10/%3Fsuper.png)4. 副作用 容器的部分功能会失效 盘子容器具有get和set的方法 class Plate{ private T item; public Plate(T t){item = t;} public void set(T t){item = t;} public T get(){return item;} } 12* 4.1 上界&lt;? extends T&gt;不能往里存, 只能往外取 set 方法会失效, 但 get 方法有效 Plate&lt;? extends Fruit&gt; p = new Plate(new Apple()); //不能存入元素 p.set(new Fruit()); //ERROR p.set(new Apple()); //ERROR //读取出来的东西只能存放在Fruit和它的基类 Fruit fruit = p.get(); Object object = p.get(); Apple apple = p.get();//ERROR 12编译器在看到 Plate&lt;Apple&gt; 后, 盘子没有被标上&quot;苹果&quot;, 而是标上一个占位符 CAP#1, 来表示捕获一个 Fruit 或 Fruit 的子类, 具体是什么类, 不知道, 所以以后想往里插入Apple 或者 Meat / Fruit, 编译器都不知道能不能和 CAP#1 匹配, 所以就都不允许.所以 通配符&lt;?&gt; 和 类型参数&lt;T&gt; 的区别在于, 对于编译器来说, 所有的T, 都代表同一种类型 public List fill(T…t); 123 这里T要么都是String, 要么都是Integer, 反正保持一致 而Plate&lt;?&gt;表示, 盘子里放的是什么, 我不知道* 4.2 下界&lt;? super T&gt; 可以往里存, 但是取出来时只能放在 Object; Plate&lt;? super Fruit&gt; p = new Plate(new Fruit()); //存入元素正常p.set(new Fruit());p.set(new Apple()); //读取出来的东西只能存放在ObjectApple apple = p.get(); //ERRORFruit fruit = p.get(); //ERRORObject object = p.get();``` PESC原则Producer Extends Consumer Super 频繁往外读取内容, 适合用上界Extends 经常往里插入内容, 适合用下界Super 参考 Android面试一天一题（7 Day） 知乎 | Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？| 胖胖的回答","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.fredsun.me/tags/Java/"},{"name":"Lambda","slug":"Lambda","permalink":"http://www.fredsun.me/tags/Lambda/"},{"name":"泛型","slug":"泛型","permalink":"http://www.fredsun.me/tags/泛型/"}]},{"title":"Day11 - Activity","slug":"Day11-Activity","date":"2017-08-31T08:09:00.000Z","updated":"2017-12-26T06:33:09.753Z","comments":true,"path":"2017/08/31/Day11-Activity/","link":"","permalink":"http://www.fredsun.me/2017/08/31/Day11-Activity/","excerpt":"Activity 生命周期, 启动模式, Activity栈","text":"Activity 生命周期, 启动模式, Activity栈 生命周期 onCreate(); onStart(); 可见, onResume(); 可操作,在前台 onPause(); onStop(); onDestroy(); onRestart(); 返回前activity, 让他重新启动 当Activity只执行onPause方法时（透明Activity），这时候如果App设置的targetVersion大于11则不会执行onSaveInstanceState方法 处理广播, 在onStart和onStop, onResume和onPause易触发并且可能只是暂时不能执行(被透明activity挡住)跳转B前操作数据库, 并且B需要数据库, 在onPause,12345onPauseonCreate--BonStart--BonResume--BonStop 所以得确保B没出来的时候数据加载完毕, 但是如果B是半透明的, 则不会执行onStopB返回A 123456onPause -BonRestartonStartonResumeonStop --BonDestroy --B 黑屏/按home/按任务列表生命周期: 12345onPauseonStoponRestartonStartonResume 横竖屏切换生命周期,此时开 alertDialog.Builder 格式的dialog, 生命周期不影响 123456onPauseonStoponDestroyonCreateonStartonResume Activity 是否运行(activity == null || activity.isDestroyed() || activity.isFinishing())原因: isFinishing 根据 mFinished, mFinished只在无法确定finish一定会执行, 且 finish 执行后, 无法保证立马走到 onDestroy1234```public boolean isFinishing() &#123; return mFinished; &#125; 根据Google源码中的Dialer应用的源码Link, 添加 isDestroyed 判断123456789101112@Override protected void onPostExecute(Void result) &#123; final Activity activity = progressDialog.getOwnerActivity(); if (activity == null || activity.isDestroyed() || activity.isFinishing()) &#123; return; &#125; if (progressDialog != null &amp;&amp; progressDialog.isShowing()) &#123; progressDialog.dismiss(); &#125; &#125; onUserLeaveHint 和 onUserInteraction onUserLeaveHint当用户的操作导致activity即将进入后台的时候, 此方法会被调用, 但在来电时不被调用 onUserInteractionactivity 在分发各种事件之前会调用, 但启动另一个activity会被调用两次, 一次是 activity 补货到事件时, 一次是调用activity.onUserLeaveHint之前会调用onUserInteraction 临时状态保存 – onSaveInstanceState 和 onRestoreInstanceState 是用来临时存储数据, 长期的还是需要数据库 前提是view必须有ID 保存状态 onSaveInstanceState(Bundle savedInstanceState)执行在 onStop 之前 back不会触发 finish()不会触发 home触发 任务列表键会触发 跳转 Activity 会触发 旋转屏幕会触发 黑屏会触发 Activity 创建时有一个 bundle 对象, 该对象是上次被系统销毁时在 onSaveInstanceState 保存的参数, 123456789101112 static final String STATE_SCORE = \"playerScore\";static final String STATE_LEVEL = \"playerLevel\";@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) &#123; // Save the user's current game state savedInstanceState.putInt(STATE_SCORE, mCurrentScore); savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel); // Always call the superclass so it can save the view hierarchy state super.onSaveInstanceState(savedInstanceState);&#125; 注意，自定义的部分在super之前 使用onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState), 则onSaveInstanceState不会被调用 onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState)API21 后添加的属性, 能在关机重启后拥有数据恢复的功能, 需要在 manifest 中给 acticity 添加属性 1android:persistableMode=&quot;persistAcrossReboots&quot; 须 重写 onCreate(Bundle savedInstanceState, PersistableBundle persistentState), 并不用普通的 onCreate 和 onSaveInstanceState 重写此onSaveInstanceState会导致 onSaveInstanceState 不执行 恢复状态 onRestoreInstanceState执行在 onStart 之后, 只有有savedInstanceState时才会调用, 无需判空 12345678public void onRestoreInstanceState(Bundle savedInstanceState) &#123; // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState); // Restore state members from saved instance mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);&#125; onCreate中恢复, 需判空 1234567891011121314 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we're recreating a previously destroyed instance if (savedInstanceState != null) &#123; // Restore value of members from saved state mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL); &#125; else &#123; // Probably initialize members with default values for a new instance &#125; ...&#125; 透明activity(继承AppCompatActivity) 透明color 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;resources&gt; &lt;color name=&quot;transparent&quot;&gt;#0000&lt;/color&gt; &lt;/resources&gt; style设置background, style的parent不加会报错: need to use a Theme.AppCompat theme (or descendant) with this activity.```123456789```&lt;style name=&quot;myTransParent&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name =&quot;android:windowBackground&quot;&gt;@color/transParent&lt;/item&gt; &lt;item name =&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name =&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name =&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt; &lt;item name =&quot;android:windowAnimationStyle&quot;&gt;@android:style/Animation.Translucent&lt;/item&gt; &lt;item name =&quot;android:statusBarColor&quot;&gt;@color/transParent&lt;/item&gt;&lt;/style&gt; 清单设置 activity 的 theme 1android:theme=&quot;@style/myTransparent&quot; ActivityA 打开透明ActivityB1234onPauseonCreate --BonStart --BonResume --B 透明ActivityB返回ActivityA1234onPause --BonResumeonStop --BonDestroy --B 启动模式A组件运行在A应用, A组件调用系统的照相组件, 虽然不在一个应用, 但是安卓运行跨应用组件, 虽然两者不在一个进程, 但是可以通过Task来实现, Task可以理解为实现一个功能而负责管理所有用到的 Activity实例的栈 standard默认, 先进后出 singleTop栈顶不重复, 唯一如果要开启的 activity 已经在栈顶存在, 就不会创建新的实例, 而去调用 onNewIntent().如果栈顶没有, 则创建新的实例比如 通知栏的通知点击打开activity, 用singleTop可以避免重复创建快速点击不能只依赖这个, 不靠谱, 第一个栈实例可能还没入栈,就创建了第二个然后和第一个一起入栈了, 建议对快速点击另作判断 singleTask栈内不重复, 干掉头上的其他activity如果要开启的activity已经在栈内存在, 就不会创建新的栈和新的实例, 而去调用 onNewIntent(), 并且清空它上面的所有activity比如 主界面, 保证主界面上面没有activity singleInstance单一实例, 单一栈, 栈里只有自己谨慎使用如果要开启的activity已经在进程中存在, 就不会创建新的实例, 而去调用 onNewIntent().比如 呼叫来电界面 指定启动模式manifest指定12&lt;activity android:name=&quot;.SecondActivity&quot; android:launchMode=&quot;singleTask&quot;/&gt; 代码指定1234Intent intent = new Intent(MainActivity.this, SecondActivity.class); //通过 intent.addFlags 设置 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 对比 代码指定优先于 manifest manifest无法设定singleInstance模式 Intent.FLAG_: FLAG_ACTIVITY_NEW_TASK = 开新栈, 多用在service和Application, 因为他俩没有栈 FLAG_ACTIVITY_SINGLE_TOP = singleTop FLAG_ACTIVITY_CLEAR_TOP = singleTask FLAG_ACTIVITY_NO_HISTORY 启动完其他的后, 自己消失 LaunchMode + StartActivityForResult 在 5.0 分水岭 5.0 之前可能不回调 5.0 后全部有回调adb 查看任务栈 运行 1adb shell dumpsys activity 搜 Recent tasks 查看已经存在的任务栈 1234Recent tasks: * Recent #0: TaskRecord&#123;5bd8fdd #749 A=com.taskaffinity U=0 sz=1&#125; * Recent #1: TaskRecord&#123;a972e43 #748 A=com.activityfull U=0 sz=1&#125; * Recent #2: TaskRecord&#123;7a2180c #664 I=com.android.launcher3/.Launcher U=0 sz=1&#125; 搜 Running activities (most recent first)查看activity 1234Running activities (most recent first): TaskRecord&#123;25d22cd #684 A=com.activityfull U=0 sz=2&#125; Run #1: ActivityRecord&#123;8e55d0b u0 com.activityfull/.SecondActivity t684&#125; Run #0: ActivityRecord&#123;d26b857 u0 com.activityfull/.MainActivity t684&#125; 栈的唯一标号是#682, sz 表示栈内有几个组件, 栈顶的是 SecondActivity, Recent tasks查看手机程序的任务栈, != 应用数(一个应用可能包含多个栈), 更不是进程数任务栈数 = 手机任务列表里显示的数量 + com.android.launcher + com.android.systemui 12345ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents) Recent tasks: * Recent #0: TaskRecord&#123;42a273f #682 A=com.activityfull U=0 sz=1&#125; * Recent #1: TaskRecord&#123;7a2180c #664 I=com.android.launcher3/.Launcher U=0 sz=1&#125; * Recent #2: TaskRecord&#123;8a01555 #667 A=com.android.systemui U=0 sz=1&#125; android:exported=”true”允许其他app打开这个activity taskAffinity + allowTaskReparenting taskAffinity设置activity进入指定完整栈名的栈,一般和singleTask一起使用 Application中设置(推荐activity设置), 不设定则默认包名, 设定了内部 Activity和 Application一致 Activity 中设置, 如果指定的任务栈不存在, 那么会自己新开一个指定包名的任务栈 allowTaskReparenting是否依附与开启这个 Activity 的任务栈 举例: APP1 内有 activity1, activity2; APP2内有 activity3 和 activity4, 当 APP1 的 activity1 在 APP1 内打开这个 APP2 的 activity4 时, 1. 123&lt;activity android:name=&quot;.FourActivity&quot; android:exported=&quot;true&quot; /&gt; a. 只有 APP1 的任务栈打开, 存放的是 activity1 和 activity4;b. 按home, 点开 APP1 看到的是 activity4, 按back, 看到activity1, 按back, 退出c. 按home, 点开 APP2 看到的是 activity3, 按back, 退出 2. 1234&lt;activity android:name=&quot;.FourActivity&quot; android:exported=&quot;true&quot; android:allowTaskReparenting=&quot;true&quot; /&gt; a. 只有 APP1 的任务栈打开, 存放的是 activity1 和 activity4;b. 按home, 点开 APP1 看到的是 activity1,c. 按home, 点开 APP2 看到的是 activity4, 按back, 看到activity3, 按back, 退出 3. 12345&lt;activity android:name=&quot;.FourActivity&quot; android:exported=&quot;true&quot; android:allowTaskReparenting=&quot;true&quot; android:launchMode=&quot;singleTask&quot; /&gt; a. APP1 任务栈存放 activity1, APP2 的任务栈存放activity4b. 按home, 点开APP1 看到的是 activity1c. 按home, 点开APP2 看到的是 activity4, 按back退出 Intent.Flag Intent.FLAG_ACTIVITY_NEW_TASK单独使用无效果, 需和 taskAffinity 一起使用, 当使用 Intent.FLAG_ACTIVITY_NEW_TASK + taskAffinity 指定非包名的任务站名 == android:launchMode=”singleInstance” Intent.FLAG_ACTIVITY_SINGLE_TOP == android:launchMode=”singleTop” Intent.FLAG_ACTIVITY_CLEAR_TOP 与 android:launchMode=”singleTask”类似, 但是如果栈顶是自身, 会毁旧建新, 重走生命周期, 而不是 onNewIntent. 当目标activity已经存在的时候才会干掉其他activity Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有这个标记的Activity不会出现在Activity的历史列表中.他等同于在xml里面设定 android:excludeFromRecents=”true” 。 打开其他APP Link通过 APP 打开一个 APP1234567891011121314151617181920212223PackageManager packageManager = getPackageManager(); if (checkPackInfo(packname)) &#123; Intent intent = packageManager.getLaunchIntentForPackage(packname); startActivity(intent); &#125; else &#123; Toast.makeText(MainActivity.this, &quot;没有安装&quot; + packname, 1).show(); &#125; /** * 检查包是否存在 * * @param packname * @return */ private boolean checkPackInfo(String packname) &#123; PackageInfo packageInfo = null; try &#123; packageInfo = getPackageManager().getPackageInfo(packname, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return packageInfo != null; &#125; 打开其他APP的Actvitiy123456789101112Intent intent = new Intent(); //第一种方式 ComponentName cn = new ComponentName(&quot;com.example.fm&quot;, &quot;com.example.fm.MainFragmentActivity&quot;); try &#123; intent.setComponent(cn); //第二种方式 //intent.setClassName(&quot;com.example.fm&quot;, &quot;com.example.fm.MainFragmentActivity&quot;); intent.putExtra(&quot;test&quot;, &quot;intent1&quot;); startActivity(intent); &#125; catch (Exception e) &#123; //TODO 可以在这里提示用户没有安装应用或找不到指定Activity，或者是做其他的操作 &#125; 需要将目标Activity的android:exported=”true”属性在所属应用AndroidMainfest里设置为true，意思是当前Activity可以被外部应用访问，否则会报下面的错误 123Caused by: java.lang.SecurityException: Permission Denial: starting Intent&#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125; (pid=11545, uid=10071) not exported from uid 10067 需要在当前应用的AndroidMainfest里也声明目标Activity，否则会报下面的错误（5.0以后好像不会有这个错，我用的了两个5.0一下的测试机都报错了） 123Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; have you declared this activity in your AndroidManifest.xml? 在清单文件里面添加目标Activity就成 1&lt;activity android:name=&quot;com.example.fm.MainFragmentActivity&quot;&gt;&lt;/activity&gt; 参数传递普通数据直接在Intent中添加bundle.如果需要传递类, 因为 Activity 和 Fragment无法直接传递类, 所以需要序列化, 序列化的方式分为 java 自带的 Serializable 或者 Android 自带的 Parcelable Serializablejava自带的, 基于反射实现, 将对象存入字节流, 序列化的过程需要进行大量I/O操作, 速度较慢, 产生大量临时的对象, 容易触发GC Parcelableandroid提供的, 为了IPC(进程间通信机制)而设计 parcel, 原理是将对象分解, 分解后的每一部分Intent都可以直接使用自己实现了封送和解封不需要反射, 数据也存在Native内存, 但是它无法很好的持久化保存数据, 对比: onNewIntentsingleTask等模式, 如果 Activity 还在任务栈, 且没被销毁, 则会调用 onNewIntent, 否则还是走onCreate.onNewIntent(intent)中的intent是此次的intent, 但是getIntent 是上一次的intent. 参考 android onUserLeaveHint和onUserInteraction Google | 重新创建 Activity 简书 | 我打赌你一定没搞明白的Activity启动模式 简书 | Android通过App启动另一个APP 简书} Android-Activity所应该了解的大概就这样。（中） Android中onNewIntent()的用法","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://www.fredsun.me/tags/Activity/"},{"name":"Activity栈","slug":"Activity栈","permalink":"http://www.fredsun.me/tags/Activity栈/"}]},{"title":"Day10 - 尝试搭自己的服务器","slug":"Day10-idea,maven,spring boot,vim","date":"2017-08-25T02:06:00.000Z","updated":"2017-10-20T06:49:32.443Z","comments":true,"path":"2017/08/25/Day10-idea,maven,spring boot,vim/","link":"","permalink":"http://www.fredsun.me/2017/08/25/Day10-idea,maven,spring boot,vim/","excerpt":"OOM举例分析","text":"OOM举例分析 tips: Springboot项目打开是打开pom.xml BUGidea新建Spring boot 项目无法运行, java 文件的import全部报错, pom的一片红(version, artifactId报红)解决方案: 从preference -&gt; 搜maven -&gt; 拿到Local repository的路径, mac下是1234567891011121314151617181920212223242526272829303132333435363738394041424344454647然后把.m2文件夹下的文件(**包括repository本身!!!!!!**)删除, 回到项目, 右键pom文件, 选择maven -&gt; Reimport![](https://raw.githubusercontent.com/sunxlfred/RES/83fb4e9c523f6b5a14f947cf176d77b3db2c726b/pom-reimport.png)错误的repository:![](https://raw.githubusercontent.com/sunxlfred/RES/master/badrepository.png)正确的repository:![](https://raw.githubusercontent.com/sunxlfred/RES/83fb4e9c523f6b5a14f947cf176d77b3db2c726b/pom_bug.png)# MySql1. mysql[安装](http://www.jianshu.com/p/fd3aae701db9)2. 安装mysql忘记root账户的密码, [重置root密码:](https://www.zhihu.com/question/41158204) 1. 关闭mysql sudo /usr/local/mysql/support-files/mysql.server stop 2. cd /usr/local/mysql/bin 进入目录 3. sudo su 获取权限 4. ./mysqld_safe --skip-grant-tables &amp; 重启服务器 5. 重开个终端 配置短命令 alias mysql=/usr/local/mysql/bin/mysql **或者之前在profile中设置过path可跳过这句** 1. 输入mysql进入mysql命令模式 2. use mysql 进入数据库 3. flush privileges; 获取权限, 别漏了分号 4. set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;新密码&apos;); 完成修改,别漏分号 5. quit 退出编辑# MySql WorkBench* 在 User and Privileges 给 User 添加 Schema Privileges, 发现没有&apos;add Entey...&apos;按钮, 拉一拉窗口........= =# Vimvim readme.txt #用于编辑文本i #进入编辑Esc #进入命令模式!q #不保存退出:q! 强制退出，不保存:wq! 强制保存并退出:w &lt;文件路径&gt; 另存为:saveas 文件路径 另存为:x 保存并退出:wq 保存并退出mac搭建java服务器idea新建pom无法更新maven http://blog.csdn.net/a58YYXG/article/details/68060226* 查询端口占用 lsof -i tcp:8080 123 该命令会显示占用8080端口的进程，有其 pid ,可以通过pid关掉该进程* 杀死进程,根据上一步查出的pid kill pid 123456789101112131415161718192021222324252627# Android程序猿来搭建服务器* [参考](http://www.jianshu.com/p/6ac49000dcb2)# Mac搭建tomcat服务器mac自带了tomcat, 我们不需要安装, 只需要配置一下路径和权限首先, 在你的用户名下面新建站点, Users/用户名/新建手动新建：直接新建一个叫Sites文件夹命令新建：sudo mkdir ~/Sites1. 路径切换到Apache: cd /etc/apache2备份文件，以防不测，只需要执行一次就可以了：sudo cp httpd.conf httpd.conf.bak**// 提示：下面这行代码不要打，如果后续操作出现错误！才需要使用以下命令，恢复备份过的 httpd.conf 文件**sudo cp httpd.conf.bak httpd.conf2. 开启Apache命令开启：sudo apachectl start 启用 Apache 之后，在浏览器中访问http://localhost 或 http://127.0.0.1，如果出现“It works!”就表示运行正常。3. 修改配置文件// 用vim编辑httpd.confsudo vim httpd.conf// 查找DocumentRoot /DocumentRoot12345![](https://github.com/sunxlfred/RES/raw/0d4f58fbfd63d9c0d2944daf2472c61681116f11/tomcat_change_Document)按下 i 进入编辑模式可以看到有两个路径 把他们都改成你刚才建的那个Sites 文件夹的路径再查找下 php /php1234567![](https://github.com/sunxlfred/RES/raw/0d4f58fbfd63d9c0d2944daf2472c61681116f11/tomcat_change_php)定位到这一行后把光标移到最左边按下 x 删除“#”（如果是10.10系统的话还有一步：查找Options 输入/Options 也可以目测自己找到图中的位置，在Options和Follow之间增加一个单词Indexes）改好之后先按下esc键退出编辑模式，再输入:wq 保存并退出 如果打错了不想保存就是 :q!服务器开关的命令就是 sudo apachectl -k start 开启 sudo apachectl -k stop 关闭``` 参考 Android程序猿来搭建服务器 Mac（OS X）安装、配置并使用MySQL数据库 Mac 搭建本地Apache服务器 CSDN | Mac系统查看端口占用和杀死进程 IntelliJ IDEA打开Maven项目，所有依赖红名，不可用，简单解决方案","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"OOM","slug":"OOM","permalink":"http://www.fredsun.me/tags/OOM/"},{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"idea","slug":"idea","permalink":"http://www.fredsun.me/tags/idea/"},{"name":"maven","slug":"maven","permalink":"http://www.fredsun.me/tags/maven/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.fredsun.me/tags/spring-boot/"},{"name":"vim","slug":"vim","permalink":"http://www.fredsun.me/tags/vim/"}]},{"title":"Day9 - OOM + Context","slug":"Day9-OOM与Context","date":"2017-08-24T07:45:00.000Z","updated":"2017-12-28T08:19:35.563Z","comments":true,"path":"2017/08/24/Day9-OOM与Context/","link":"","permalink":"http://www.fredsun.me/2017/08/24/Day9-OOM与Context/","excerpt":"OOM举例分析","text":"OOM举例分析 Tips: Lint工具静态分析可能错误jump LeakCanary 检测内存泄漏 第一种 布局的锅最初学习创建 Fragment, 在 inflate 时, 往往会忘记第三个参数123inflate（int resources, 当前布局D ViewGroup root, 根布局G boolean attachToRoot 是否依赖根布局G）, 而去使用了两个参数的方法, 即第三个参数为true, 当new Fragment时 (多为 viewPager 添加Fragment), 会报 OOM, 没有特殊情况, attachToRoot 置为 false 第二种 Context 和 非静态内部类什么是 Context四大组件中 Activity, Service, 甚至 Application 的创建都离不开 ContextContext是一个抽象类, 提供了应用环境全局信息的接口, 它允许获取以应用为特征的资源和类型.就是说通过它我们可以进行应用程序级别的操作(获取资源, 启动 activity, service, 接收intent),context的子类是实现子类 ContextImpl 和 包装子类 ContextWrapper, 虽然 Activity, Application, service 都是 ContextWrapper 的子类, 但是它们的初始化过程都需要创建 ContextImpl 对象, 由 ContextImpl 对象实现Context中的方法. 一个应用中有几个context应用中 Context 的数量 = Activity 的数量 + Service 的数量 + 1（Application 的数量), Context的作用域由于Context的具体实例都是由 ContextImpl 实现的, 因此在绝大多数场景下, Activity, Service 和 Application的context是可以通用的.不过也有特殊的情况, 比如 Android 规定 Activity 和 Dialog 不能凭空出现, 一个Activity 的启动必须建立在另一个 Activity 的基础之上, 实现回退栈结构. Dialog 也必须实现在 Activity 之上, System 级的 Dialog 除外 举例ApplicationContext 去启动 LaunchMode为 Standard的Actvity, 会报错.原因: 非 Activity 级的 context 没有回退栈, 所以用 FLAG_ACTIVITY_NEW_TASK, 创建一个新的任务栈, 此时 Activity 是以 SingleTask 模式启动的 几种context的总结 Context.getApplicationContext();和整个app的生命周期绑定, 可能因供应商而出问题, 不推荐 ContextWrapper.getBaseContext();从另一个上下文里获取context, 不推荐 Activity.getApplication();自建Application类, 提供静态方法, 尽量不使用 View.getContext();获取当前view的context, 通常是当前运行的activity 几种getResources总结 Link &amp; ~~被废弃 [Link](https://stackoverflow.com/questions/29041027/android-getresources-getdrawable-deprecated-api-22/29041466)11. 使用drawable资源但不为其设置theme主题ResourcesCompat.getDrawable(getResources(), R.drawable.name, null); 12. 使用默认的activity主题 ContextCompat.getDrawable(getActivity(), R.drawable.name); 123. 使用自定义主题 ResourcesCompat.getDrawable(getResources(), R.drawable.name, anotherTheme); 123456789101112131415161718### Context 造成 OOM#### a. static方法保存了contextActivity 传入 context 实例 Util 后, 即使 activity 被销毁, 它的引用还是被Util保存, 不会被GC.```javapublic class Util &#123; private Context mContext; private static Util sInstance; private Util(Context context) &#123; this.mContext = context; &#125; public static Util getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new Util(context); &#125; return sInstance; &#125; //other methods &#125; 非静态内部类和匿名内部类是会隐式持有外部类的引用(所以adapter可以作为单独一个包), GC的回收机制是有强引用的对象不会被回收静态内部类不持有外部类的引用,且静态内部类可持有静态数据, 静态方法, 嵌套静态内部 解决方案: 传入Application.Context(不建议, 可能导致ApplicationContext的泄漏jump 自己将持有引用的量在onDestroy里置为null 弱引用 b. adapter持有contextactivity 创建 adapter 时传入 context, adapter 进行了耗时操作, 此时finish 掉 activity, activity被销毁, adapter没有置为null, adapter无法被回收解决方案: * 外部Adapter, 根据adapter的getView(int position, View convertView, ViewGroup parent)中的parent.getContext()获取, 如果需要button点击跳转, 添加接口回调.虽然这里的parent.getContext和原先传入的context一样, 但是Adapter不需要将activity保存在成员变量中, adapter就不会持有activity的引用了 * 内部Adapter, 添加static c. Drawable(3.0前的bug, SDK已修复)123456789101112131415private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123;super.onCreate(state);TextView label = new TextView(this);label.setText(\"Leaks are bad\");if (sBackground == null) &#123;sBackground = getDrawable(R.drawable.large_bitmap);&#125;label.setBackgroundDrawable(sBackground);setContentView(label);&#125; public void setBackgroundDrawable(Drawable background) { … background.setCallback(this); } 看一下源码1234public void setBackgroundDrawable(Drawable background) &#123; ... background.setCallback(this); &#125; 这里, Drawable持有了TextView的引用, TextView持有了Activity的引用, 所以Drawable持有了activity的引用, 3.0后在setCallback里添加了WeakReference, 所以bug被官方修复了123public final void setCallback(Callback cb) &#123; mCallback = new WeakReference&lt;Callback&gt;(cb);&#125; 总结 不要在Activity使用非静态内部类, 使用静态内部类, 并且将外部的引用作为弱引用持有(弱引用须判空), 常用于Handler 参考 告诉你ListView的Adapter应该写在Activity外面还是里面 Java中的内部类和匿名类 Context 都没弄明白，还怎么做 Android 开发？ 匿名内部类持外部引用造成内存泄漏问题 Android中使用Handler引发的内存泄露 待补充","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"OOM","slug":"OOM","permalink":"http://www.fredsun.me/tags/OOM/"},{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"}]},{"title":"Day8 - Fragment懒加载+ViewPager+TabLayout","slug":"Day8-Fragment懒加载+ViewPager+TabLayout","date":"2017-08-23T06:37:00.000Z","updated":"2017-12-28T08:19:28.493Z","comments":true,"path":"2017/08/23/Day8-Fragment懒加载+ViewPager+TabLayout/","link":"","permalink":"http://www.fredsun.me/2017/08/23/Day8-Fragment懒加载+ViewPager+TabLayout/","excerpt":"Fragment懒加载示例","text":"Fragment懒加载示例 Tips:如何设置 xml 的属性预览可见, 运行不可见方法: xml 根布局添加xmlns:tool=”http://schemas.android.com/tools“, 子控件命名空间设置tool:text等, 只在Design视图能看见, 运行后不可见 Link FragmentViewPager打开第 1 个fragment时会打开第 2 个 fragment 并执行第 2 个的生命周期从 ```onResume```（点击第 2 个时会打开第 3 个的...), 为避免在 ```onCreateView``` 里进行太多操作, 我们考虑只在 **fragment可见** && **第一次加载** 时 进行数据加载12345678910&gt; * Fragment 搭配 ViewPager 时会多在生命周期夺走一个方法```setUserVisibleHint()```, 我们可手动调用```getUserVisibleHint```看回调&gt; * ```setUserVisibleHint()```用在单个 Fragment 时不会被调用&gt; * ```setUserVisibleHint()``` 调用在onAttach之前&gt; ![](https://raw.githubusercontent.com/sunxlfred/RES/master/lazyLoad1.png)## 如何懒加载(两种)1. Fragment.setUserVisibleHint2. ViewPager.addOnPageChangeListener里的```onPageSelected(int position) 第一种.setUserVisibleHint我们需要做的判断 fragment可见, 我们可以根据setUserVisibleHint时判断isVisibleToUser 是否加载过View, 通过自己创建标识位 是否加载过数据, 通过自己创建标识位 写法 先写 BaseFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class BaseFragment extends Fragment &#123; protected Activity mActivity; protected View mRootView; private Unbinder unbinder; /** * 说明：在此处保存全局的Context * * @param context 上下文 */ @Override public void onAttach(Context context) &#123; super.onAttach(context); mActivity = (Activity) context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; mRootView = inflater.inflate(getLayoutId(), container, false); unbinder = ButterKnife.bind(this, mRootView); init(); return mRootView; &#125; /** * @return 返回该Fragment的layout id */ protected abstract int getLayoutId(); /** * 说明：创建视图时的初始化操作均写在该方法 */ protected abstract void init(); /** * 获取控件对象 * * @param id 控件id * @return 控件对象 */ public View findViewById(int id) &#123; if (getContentView() != null) &#123; return getContentView().findViewById(id); &#125; else &#123; return null; &#125; &#125; /** * 说明：返回当前View * * @return view */ protected View getContentView() &#123; return mRootView; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind(); &#125;&#125; 再写 lazyFragment 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 懒加载Fragment * * 可以加载数据的条件： * 1.视图已经初始化 * 2.视图对用户可见 */public abstract class LazyLoadFragment extends BaseFragment &#123; public boolean isInit = false;//视图是否已经初始化 public boolean isLoad = false;//视图是否已经加载过 /** * 初始化 */ @Override protected void init() &#123; isInit = true; isCanLoadData(); &#125; /** * 判断是否可以加载数据, 如果可以便进行数据的加载 */ private void isCanLoadData() &#123; if (!isInit) &#123;//未初始化 return; &#125; if (getUserVisibleHint()) &#123;//用户可见 lazyLoad(); isLoad = true; &#125; else &#123; if (isLoad) &#123;//用户不可见, 且已经加载过 stopLoad(); &#125; &#125; &#125; /** * 当视图初始化并且对可见时加载数据 */ public abstract void lazyLoad(); /** * 当该视图对用户不可见并且已经加载过数据的时候, 如果需要在切换到其他页面时停止加载数据, 通过覆写此方法实现 */ public void stopLoad() &#123; &#125; /** * 说明：当前视图可见性发生变化时调用该方法 * * @param isVisibleToUser 当前视图是否可见 */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); isCanLoadData(); &#125; /** * 视图销毁时将Fragment是否初始化的状态变为false */ @Override public void onDestroyView() &#123; super.onDestroyView(); isInit = false; isLoad = false; &#125;&#125; 第二种, 通过onPageSelected判断缺点: 第 1 页第 1 次进入不调用 onPageSelected12345678910111213141516171819202122viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; // TODO fragment.initData(); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125;);作者：最最最最醉人链接：http://www.jianshu.com/p/843088e1ad40來源：简书著作权归作者所有。商业转载请联系作者获得授权, 非商业转载请注明出处。 PagerAdapter分为三种123（1）PagerAdapter 数据源：List&lt;View&gt; 适合轮播图,图片查看等 (2)FragmentPagerAdapter 数据源：List&lt;Fragment&gt; (3)FragmentStatePagerAdapter 数据源：List&lt;Fragment&gt; FragmentPagerAdapter 和 FragmentStatePagerAdapter区别 FragmentPagerAdapter: fragmentTransaction()调用depatch(), 生命周期走到onDestroyView(), 适合主界面, 页面少, 只回收view, 数据保留 FragmentStatePagerAdapter: fragmentTransaction()调用remove(), 生命周期走到onDetach（）, 适合多页面, 数据多, view和data都回收, 但也会调onSaveInstance方法, 可存在bundle. 使用FragmentStatePagerAdapter打开多个Fragment: 第一次进入页面 12345678910111213140: onAttach0: onCreate1: onAttach1: onCreate0: onCreateView0: onViewCreated0: onActivityCreated0: onStart0: onResume1: onCreateView1: onViewCreated1: onActivityCreated1: onStart1: onResume 从第0页到第1页 1234562: onAttach2: onCreate2: onCreateView2: onViewCreated2: onStart2: onResume 从第1页到第2页, 会把第0页杀到 **1 3: onAttach 3: onCreate 0: onPause 0: onStop 0: onDestroyView 0: onDestroy 0: onDetach 3: onCreateView 3: onViewCreated 3: onActivityCreated 3: onStart 3: onResume 124. 从第1页到第0页 2: onPause 2: onStop 2: onDestroyView 2: onDestroy 2: onDetach 125. **FragmentPagerAdapter则是让不可见的页面其生命周期走到onDestroyView** 3: onAttach 3: onCreate 0: onPause 0: onStop 0: onDestroyView 3: onCreateView 3: onViewCreated 3: onActivityCreated 3: onStart 3: onResume 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#### adapter到底是外部还是内部的* adapter别持有Activity的context, 否则可能内存泄漏OOM* 尽量 **内部**, 按照谷歌的示例#### tab关联viewpager* tabLayout.setupWithViewPager(viewpager); 传入viewpager* **```setupWithViewPager```方法会在```populateFromPagerAdapter```清空tab, 再调用```getPageTitle```, 所以正确设置tab的方式是getPageTitle里拼CharSequence** [Link](http://www.jianshu.com/p/d83f10c1a765) ```java //...省略一部分代码 //处理从方法中传入的viewpager if (viewPager != null) &#123; mViewPager = viewPager; //①以下这部分代码是处理一些滑动的关联关系。例如滑动监听 // Add our custom OnPageChangeListener to the ViewPager if (mPageChangeListener == null) &#123; mPageChangeListener = new TabLayoutOnPageChangeListener(this); &#125; mPageChangeListener.reset(); viewPager.addOnPageChangeListener(mPageChangeListener); // Now we&apos;ll add a tab selected listener to set ViewPager&apos;s current item mCurrentVpSelectedListener = new ViewPagerOnTabSelectedListener(viewPager); addOnTabSelectedListener(mCurrentVpSelectedListener); //②以下这部分代码就可以解释为什么我们的tab设置的内容会不见了 final PagerAdapter adapter = viewPager.getAdapter(); if (adapter != null) &#123; // Now we&apos;ll populate ourselves from the pager adapter, adding an observer if // autoRefresh is enabled //将外部设置给viewpager的adapter取出来通过setPagerAdapter重新设置 setPagerAdapter(adapter, autoRefresh); &#125; ... &#125; ... &#125; void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; //注册observer mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter //关键代码 populateFromPagerAdapter(); &#125; void populateFromPagerAdapter() &#123; //移除所有的tab //我们之前设置的tab就是在这里被移除的 removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; //重新添加tab, 而setText得内容是在PagerAdapter中getPageTitle获取的, 因此问题的答案就已经很明显了。 addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) &#123; final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123; selectTab(getTabAt(curItem)); &#125; &#125; &#125; &#125; 作者：liaoweijian 链接：http://www.jianshu.com/p/d83f10c1a765 來源：简书 著作权归作者所有。商业转载请联系作者获得授权, 非商业转载请注明出处。 tab添加标题 adapter的position)```返回每个pager对应的标题名123456789101112131415#### tab添加图片* adapter的```getPageTitle(int position)``` 的 CharSequence 看不见图片; 解决: 在 style 里把 **textAllCaps** 置为 false ```xmlns &lt;style name=&quot;HomeTabLayout&quot; parent = &quot;Widget.Design.TabLayout&quot;&gt; &lt;item name=&quot;tabTextAppearance&quot;&gt;@style/HomeTabTextAppearance&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;HomeTabTextAppearance&quot; parent=&quot;TextAppearance.Design.Tab&quot;&gt; &lt;!--显示tab图标--&gt; &lt;item name=&quot;textAllCaps&quot;&gt;false&lt;/item&gt; &lt;/style&gt; style可以设置在styles里, 也可以单独在xml里添加style 自定义tabItem在activity中添加, 防止将context传给外部Adapter, setupWithViewPager先执行再for循环添加view, 简单的按钮切换用selector1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; tabLayout.setupWithViewPager(viewpager); for (int i = 0; i &lt; tabLayout.getTabCount(); i++)&#123; tabLayout.getTabAt(i).setCustomView(getTabView(i)); &#125;&#125;public View getTabView(int position)&#123; View view = LayoutInflater.from(this).inflate(R.layout.tab_home_bottom, null); ImageView ivHomeTab = (ImageView) view.findViewById(R.id.iv_home_tab); ivHomeTab.setImageResource(tabIcons[position]); return view;&#125; setTabMode TabLayout.MODE_SCROLLABLE 跟着viewpager滚动 TabLayout.MODE_FIXED 固定的Tab, tabGravity.GRAVITY_FILL需要和 TabLayout.MODE_FIXED 一起使用才有效 下划线Indicator style里通过tabIndicatorColor设置颜色, tabIndicatorHeight设置宽高 处理横竖切换(待验证)1234567891011@Override public void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putInt(POSITION,tabLayout.getSelectedTabPosition()); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); viewPager.setCurrentItem(savedInstanceState.getInt(POSITION)); &#125; ViewPager保存多少个Pager 用 ViewPager.setOffscreenPageLimit(num) 保留 2 num + 1 个页面不被销毁, 即设置1时保留左右两边的 默认是1, 除非修改源码 Viewpager + PagerAdapter + TabLayout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ViewPager viewpager = (ViewPager) findViewById(R.id.viewpager); viewpager.setAdapter(new FragmentStatePagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; Fragment fragment = null; switch (position) &#123; case 0: fragment = new FragmentZero(); break; case 1: fragment = new FragmentOne(); break; case 2: fragment = new FragmentTwo(); break; case 3: fragment = new FragmentThree(); break; case 4: fragment = new FragmentFour(); break; case 5: fragment = new FragmentFive(); break; &#125; return fragment; &#125; @Override public int getCount() &#123; return 6; &#125; @Override public CharSequence getPageTitle(int position) &#123; switch (position)&#123; case 0: return \"0\"; case 1: return \"1\"; case 2: return \"2\"; case 3: return \"3\"; case 4: return \"4\"; default: return \"0\"; &#125; &#125; &#125;);TabLayout tabLayout = (TabLayout) findViewById(R.id.tablayout);tabLayout.setupWithViewPager(viewpager); 参考 通用写法 通用写法原地址 完善写法 fragment生命周期 哪些操作需要懒加载 Fragment懒加载 10条 | Fragment 懒加载实战 简书 | 如何高效的使用ViewPager, 以及FragmentPagerAdapter与FragmentStatePagerAdapter的区别 简书 | ViewPager使用详解(三):FragmentStatePagerAdapter 简书 | TabLayout使用详解 android design library提供的TabLayout的用法 Android Fragment＋ViewPager 组合, 一些你不可不知的注意事项 简书 | Android TabLayout 分分钟打造一个滑动标签页 CSDN | 告诉你ListView的Adapter应该写在Activity外面还是里面","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://www.fredsun.me/tags/Fragment/"},{"name":"懒加载","slug":"懒加载","permalink":"http://www.fredsun.me/tags/懒加载/"}]},{"title":"Day7 - 堆,栈,方法区,GC","slug":"Day7-堆,栈,方法区,GC","date":"2017-08-23T06:25:00.000Z","updated":"2017-11-07T16:00:00.000Z","comments":true,"path":"2017/08/23/Day7-堆,栈,方法区,GC/","link":"","permalink":"http://www.fredsun.me/2017/08/23/Day7-堆,栈,方法区,GC/","excerpt":"堆和栈, 内存泄漏的本质, 静态方法区在哪儿, 新生代和老年代, STW","text":"堆和栈, 内存泄漏的本质, 静态方法区在哪儿, 新生代和老年代, STW Tips 只要类持有对外部实力对象的引用, 垃圾回收机制就不会回收该对象 静态代码块只在虚拟机第一次加载类的时候运行JVM中堆和栈对比存什么 栈内存 存储基本数据类型, 局部变量和方法调用和形参,栈分为java方法栈和native方法栈, 方法栈主要记录的是方法运行时的栈帧, 每执行一个方法就会添加一个栈帧 ,方法返回后, 栈被清空, 堆等待GC回收为单个函数分配的那部分栈空间叫做栈帧(StackFrame)正在使用的栈空间叫做调用栈(CallStack)在内存中，栈是从高地址向低地址延伸的，即栈底对应高地址，栈顶对应低地址。 java线程是不是开两个栈存放不同的栈帧看具体JDK, 比如Oracle JDK和OpenJDK就是一个调用栈存放两种栈帧 堆内存 存储Java中的全部对象,this a[] 1new int[] 存放在堆, int a[] 存放在栈 Double a[] = new Double[10000000]; Double qq = 3.1d; for (int i = 0; i &lt; a.length; i++) { a[i] = qq.doubleValue(); }123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135a[i] = qq.doubleValue;a[i] = Double.valueOf(qq);a[i] = new Double(qq.doubleValue);所以此double类的值存在堆### 独有/共享* 栈内存归属于线程, 每个线程都会有一个栈内存, 其存储的变量只能在其所属的线程中可见, 栈内存可以理解成线程的私有内存, 所以叫线程栈* 堆内存的对象, 对所有线程可见, 可以被所有线程访问### 异常* 栈没有空间存储方法调用和局部变量, JVM会抛出Java.lang.StackOverFlowError* 堆没有空间存储对象, JVM会抛出java.lang.OutOfMemoryError:java heap space* 如果永久区爆了(常量池溢出, 方法区保存的 class 对象没有被及时回收掉或者 class 信息占用的内存超过了我们的配置), JVM会抛出java.lang.OutOfMemoryError:PermGen space* 纯java代码无法泄漏栈空间, 它完全被JVM掌控### 空间大小* 栈内存远小于堆内存, 栈可通过jvm参数 -XSS设置, 默认随着虚拟机和操作系统改变### 执行效率* 栈是存取效率灵活, 仅次于寄存器, 栈数据可以共享, 但栈中的数据大小和生命周期固定, 缺乏灵活性* 堆是自动分配内存大小, 生存期不用告诉编译器, 等gc回收, 但是因为动态分配内存, 存储效率会比较慢# 方法区 static* 方法区存类信息, 静态方法, 常量, 即时编译器编译后的代码* 方法区是JVM规范所描述的一个概念, 在实际的JVM实现中, 它不一定是由单一的特殊区域所实现,在Oracle JDK7 / OpenJDK7及之后的HotSpot VM里，静态变量存储在java.lang.Class对象末尾的隐藏字段里，而java.lang.Class对象存储在普通的Java heap里（不在PermGen里了）# GC(Garabage Collection)指的是堆中数据的回收, 首先堆可以划分为新生代和老年代![](https://raw.githubusercontent.com/sunxlfred/RES/master/generational_garbage_collection.png)新生代继续划分为 Eden 和 Survivor Space(幸存区), Survivor Space 再被划分成 From 和 To![](https://raw.githubusercontent.com/sunxlfred/RES/master/young_generation_memory_areas.png)新对象首先被创建在 Eden, (如果对象过大，如数组，则直接放入老年代). 在 GC 中, Eden 会被移入Survivor Space. 直到对象熬过一定的Minor GC的次数, 会被移到老年代, 老年代用Major GC来清理&gt; 内存抖动就是Young Generation 在短时间内配置大量对象### 空间占比: * 新生代 : 老年代 = 1:2 * Eden : From : To = 8:1:1### 分代收集新生代使用Minor GC, 老年代使用Major GCMinor GC 和 Major GC 统称为 Full GC所有的Minor GC 会触发全世界暂停 **STW**(stop-the-world), 停止应用程序的线程, 当然对于大多数应用，停顿的延迟可以忽略不计, 真相是大部分Eden区中的对象都能被认为是垃圾，所以不会存放到Survivor Space.现在很多的GC机制都会清理永久代(静态方法区)* JVM并不强制要求GC实现哪种GC算法&gt; 纯java代码无法泄漏栈空间, 它完全被JVM掌控, 但如果有其他资源依附在java对象上, 如native memory(DirectByteBuffer), file(fileInputStream), 那么当然自己关闭最合适* 虽然有finalizer, PhantomReference之类的让程序员向GC注册, 请求释放资源,但是GC运行时间不确定(因为是一条单独的线程), 还是自己释放的好### 可达性检测* 引用计数: 一种在jdk1.2之前被使用的垃圾收集算法，我们需要了解其思想。其主要思想就是维护一个counter，当counter为0的时候认为对象没有引用，可以被回收。缺点是无法处理循环引用。目前iOS开发中的一个常见技术ARC（Automatic Reference Counting）也是采用类似的思路。在当前的JVM中应该是没有被使用的。* 根搜算法: gc root 根据引用关系来便利整个堆, 并标记, 这称之为Mark, 之后回收掉违背Mark的对象, 解决了「孤岛效应」, 这里的gc root 指的是： * 虚拟机栈中引用的对象(栈帧中的本地变量表) * 方法区中的类静态属性引用的对象 * 方法区中的常用变量的对象 * 本地方法栈中JNI 引用的对象### java减小GC开销 [from](https://juejin.im/entry/580746885bbb50005b901a54)* 不要显示调用System.gc()此函数只是建议JVM进行GC, 无法保证立马执行* 减小临时对象的使用* 对象不用时显示置为null* 使用StringBuilder拼接字符串String的扩增是新建对象, 多次 + 会多次创建新对象* 能用基本类型就不用对象* 少用静态* 分散对象创建和删除的时间### 整理策略* 复制主要在新生代的回收上, 通过from 和 to 区的来回拷贝.对于新生成的对象, 频繁的复制可以很快找到 那些不用的对象.* 标记清除和标记整理主要在老生代的回收上, 通过根搜的标记清除或者处理掉不用的对象.整理的过程![](https://raw.githubusercontent.com/sunxlfred/RES/master/compaction_of_the_old_generation.png)清除的过程![](https://raw.githubusercontent.com/sunxlfred/RES/master/CMS_sweeping_of_old_generation.png)清除会产生碎片，对内存的利用不是很好, 但是不代表整理比清除好, 毕竟整理慢, 比如CMSGC就是使用清除而不是整理的* 具体的垃圾收集器 * 新生代收集器：有Serial收集器、ParNew收集器、Parallel Scavenge收集器 * 老生代收集器：Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器![](https://raw.githubusercontent.com/sunxlfred/RES/master/GC.png)&gt; 思考一下复制和标记清除/整理的区别，为什么新生代要用复制？因为对新生代来讲，一次垃圾收集要回收掉绝大部分对象，我们通过冗余空间的办法来加速整理过程（不冗余空间的整理操作要做swap，而冗余只需要做move）。同时可以记录下每个对象的『年龄』从而优化『晋升』操作使得中年对象不被错误放到老年代。而反过来老年代偏稳定，我们哪怕是用清除，也不会产生太多的碎片，并且整理的代价也并不会太大。作者：纳达丶无忌链接：http://www.jianshu.com/p/c9ac99b87d56來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。# 寄存器在计算机领域，寄存器是CPU内部的元件，它是有限存贮容量的高速存贮部件，可用来暂存指令、数据和地址。寄存器分为通用寄存器和特殊寄存器。通用寄存器有 ax/bx/cx/dx/di/si，在大多数指令中可以任意选用，但也有一些规定某些指令只能用某个特定的「通用」寄存器；特殊寄存器有 bp/sp/ip 等，特殊寄存器均有特定用途。在 Stack Frame 中，涉及到三种重要的特殊寄存器： * bp ( base pointer ) 寄存器 * sp ( stack poinger ) 寄存器 * ip ( instruction pointer ) 寄存器需要注意的是，不同架构的CPU，寄存器名称会添加不同的前缀来表示寄存器的大小。例如对于x86架构，字母「e」用作名称前缀，表示寄存器大小为32位；对于x86_64架构，字母「r」用作名称前缀，表示寄存器大小为64位。# 举例* 下图是linux 中一个进程的虚拟内存分布：* 图中0号地址在最下边，越往上内存地址越大。以32位地址操作系统为例，一个进程可拥有的虚拟内存地址范围为0-2^32。分为两部分，一部分留给kernel使用(kernel virtual memory)，剩下的是进程本身使用， 即图中的process virtual memory。普通Java 程序使用的就是process virtual memory.上图中最顶端的一部分内存叫做user stack. 这就是题目问的 stack. 中间有个 runtime heap。就是题目中的heap. 他们的名字和数据结构里的stack 和 heap 几乎每啥关系。注意在上图中，stack 是向下生长的; heap是向上生长的。当程序进行函数调用时，每个函数都在stack上有一个 call frame。比如对于以下程序，```javapublic void foo()&#123; //do something... println(&quot;haha&quot;); // &lt;&lt;&lt;=== 在这儿设置breakpoint 1&#125;public void bar()&#123; foo();&#125;main()&#123; bar(); println(&quot;hahaha&quot;); // &lt;&lt;&lt;=== 在这儿设置 breakpoint 2&#125; 当程序运行到breakponit1时，user stack 里会有三个frame|| main 函数的 frame－－－－－－－－－－－－－－－－－－－|| bar 函数的 frame－－－－－－－－－－－－－－－－－－－&lt;&lt;&lt;=== %ebp|| foo 函数的 frame－－－－－－－－－－－－－－－－－－－ &lt;&lt;&lt;===%esp其中 esp 和 ebp 都是寄存器。 esp 指向stack 的顶（因为stack 向下生长，esp会向下走）; ebp 指向当前frame的边界。当程序继续执行到brekapoing 2的时候stack 大概是这样的:|－－－－－－－－－－－－－－－－－－－&lt;&lt;&lt;=== %ebp|| main 函数的 frame－－－－－－－－－－－－－－－－－－－ &lt;&lt;&lt;===%esp也就是说当一个函数执行结束后，它对应的call frame就被销毁了。(其实就是esp 和 ebp分别以东，但是内存地址中的数据只有在下一次写的时候才被覆盖。)说了这么多，终于该说什么东西放在stack 上什么东西放在heap 上了。最直白的解释： 1234public void foo()&#123; int i = 0; // &lt;= i 的值存在stack上，foo()的call frame 里。 Object obj = new Object(); // object 对象本身存在heap 里， foo()的call frame 里存该对象的地址。&#125; 图片引自CMU15-213的课件https://www.cs.cmu.edu/~213/ 作者：雷博链接：https://www.zhihu.com/question/29833675/answer/45811216来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。数据结构中栈是先进后出的结构参考 Java JVM：内存溢出（栈溢出，堆溢出，持久代溢出以及 nable to create native thread 栈帧 Stack Frame 知乎 | Java虚拟机的堆、栈、堆栈如何去理解？ 以及RednaxelaFX回答下的几个链接 知乎| 为什么Java有GC还需要自己来关闭某些资源？ Java中的堆和栈的区别 简书 | JVM内存模型你只要看这一篇就够了 importnew | Minor GC、Major GC和Full GC之间的区别 掘金 | Java 垃圾回收手记","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.fredsun.me/tags/Java/"},{"name":"静态","slug":"静态","permalink":"http://www.fredsun.me/tags/静态/"},{"name":"static","slug":"static","permalink":"http://www.fredsun.me/tags/static/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://www.fredsun.me/tags/内存泄漏/"},{"name":"STW","slug":"STW","permalink":"http://www.fredsun.me/tags/STW/"}]},{"title":"Day6 - DialogFragment + AlertDialog","slug":"Day6-DialogFrament+AlertDialog","date":"2017-08-17T06:29:00.000Z","updated":"2017-12-28T08:18:11.641Z","comments":true,"path":"2017/08/17/Day6-DialogFrament+AlertDialog/","link":"","permalink":"http://www.fredsun.me/2017/08/17/Day6-DialogFrament+AlertDialog/","excerpt":"Dialog的正确用法, 以及Dialog的生命周期浅析","text":"Dialog的正确用法, 以及Dialog的生命周期浅析 Google 在官方文档中已经默认DialogFragment作为对话框的容器, 在其中填入AlertDialog或DatePickerDialog/ TimePickerDialog 优点: DialogFragment 能依靠 activity 的 onSaveInstance 和 FragmentManager 在横竖屏切换等 Activity 被杀死重建时重建对话框 缺点: TargetVersion 需定到 APILevel 11 用法自定义布局 创建布局文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" &gt; &lt;TextView android:id=\"@+id/id_label_your_name\" android:layout_width=\"wrap_content\" android:layout_height=\"32dp\" android:gravity=\"center_vertical\" android:text=\"Your name:\" /&gt; &lt;EditText android:id=\"@+id/id_txt_your_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/id_label_your_name\" android:imeOptions=\"actionDone\" android:inputType=\"text\" /&gt; &lt;Button android:id=\"@+id/id_sure_edit_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_below=\"@id/id_txt_your_name\" android:text=\"ok\" /&gt; &lt;/RelativeLayout&gt; 继承DialogFragment,重写onCreagteView 1234567@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.fragment_dialog, container); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);//去掉默认标题 return inflate;&#125; 在 activity中调用 12EditDialogFragment editDialogFragment = new EditDialogFragment();editDialogFragment.show(getFragmentManager(), \"EditNameDialog\"); 默认的dialog格式, 按钮具体的样式跟着系统版本变化 自定义布局的dialog不需要添加按钮 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" &gt; &lt;TextView android:id=\"@+id/id_label_your_name\" android:layout_width=\"wrap_content\" android:layout_height=\"32dp\" android:gravity=\"center_vertical\" android:text=\"Your name:\" /&gt; &lt;EditText android:id=\"@+id/id_txt_your_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/id_label_your_name\" android:imeOptions=\"actionDone\" android:inputType=\"text\" /&gt; &lt;Button android:id=\"@+id/id_sure_edit_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_below=\"@id/id_txt_your_name\" android:text=\"ok\" /&gt; &lt;/RelativeLayout&gt; 1234567891011@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; // Build the dialog and set up the button click handlers AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.fragment_login_dialog, null); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout builder.setView(view) .setPositiveButton(\"Sign in\",....... return builder.create(); 默认布局的dialogonAttach 拿到上下文, 判断后强转成 Listener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class NoticeDialogFragment extends DialogFragment &#123; /* The activity that creates an instance of this dialog fragment must * implement this interface in order to receive event callbacks. * Each method passes the DialogFragment in case the host needs to query it. */ public interface NoticeDialogListener &#123; public void onDialogPositiveClick(DialogFragment dialog); public void onDialogNegativeClick(DialogFragment dialog); &#125; // Use this instance of the interface to deliver action events NoticeDialogListener mListener; // Override the Fragment.onAttach() method to instantiate the NoticeDialogListener @Override public void onAttach(Context context) &#123; super.onAttach(context); // Verify that the host activity implements the callback interface try &#123; // Instantiate the NoticeDialogListener so we can send events to the host mListener = (NoticeDialogListener) context; &#125; catch (ClassCastException e) &#123; // The activity doesn't implement the interface, throw exception throw new ClassCastException(context.toString() + \" must implement NoticeDialogListener\"); &#125; &#125; ... @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; // Build the dialog and set up the button click handlers AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); builder.setMessage(R.string.dialog_fire_missiles) .setPositiveButton(R.string.fire, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int id) &#123; // Send the positive button event back to the host activity mListener.onDialogPositiveClick(NoticeDialogFragment.this); &#125; &#125;) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int id) &#123; // Send the negative button event back to the host activity mListener.onDialogNegativeClick(NoticeDialogFragment.this); &#125; &#125;); return builder.create(); &#125; &#125;&#125; 调用 12DialogFragment newFragment = new FireMissilesDialogFragment();newFragment.show(getSupportFragmentManager(), \"missiles\"); 数据传递, 在 Activity 继承接口, 实现方法 1234567891011121314151617181920212223242526public class MainActivity extends FragmentActivity implements NoticeDialogFragment.NoticeDialogListener&#123; ... public void showNoticeDialog() &#123; // Create an instance of the dialog fragment and show it DialogFragment dialog = new NoticeDialogFragment(); dialog.show(getSupportFragmentManager(), \"NoticeDialogFragment\"); &#125; // The dialog fragment receives a reference to this Activity through the // Fragment.onAttach() callback, which it uses to call the following methods // defined by the NoticeDialogFragment.NoticeDialogListener interface @Override public void onDialogPositiveClick(DialogFragment dialog) &#123; // User touched the dialog's positive button dialog.getdialog.findViewById... ... &#125; @Override public void onDialogNegativeClick(DialogFragment dialog) &#123; // User touched the dialog's negative button ... &#125; &#125; 清除对话框手动调dismiss(); 默认AlertDialog, 改button颜色先之后再getButton123456789101112131415161718192021```javaAlertDialog alertdialog = new AlertDialog.Builder(getActivity()).create(); LayoutInflater layoutInflater = getActivity().getLayoutInflater(); View view = layoutInflater.inflate(R.layout.fragment_dialog, null); alertdialog.setView(view); alertdialog.setButton(DialogInterface.BUTTON_NEGATIVE, &quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); alertdialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;ok&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); alertdialog.show(); Button button = alertdialog.getButton(alertdialog.BUTTON_POSITIVE); button.setTextColor(Color.parseColor(&quot;#00ffff&quot;)); return alertdialog; 不可点击 通用 12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);// this.setCancelable(false);&#125; dialog的另一种方式 123public Dialog onCreateDialog(Bundle savedInstanceState) &#123; dialog.setCanceledOnTouchOutside(false);// 设置点击屏幕Dialog不消失&#125; 参考 CSDN | Android 官方推荐 : DialogFragment 创建对话框* 简书 | [Android] Material 风格的 Dialog 的使用的第七条评论 CSDN | 从源码看 AlertDialog.getButton(DialogInterface.BUTTON_POSITIVE) 为什么是 null","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://www.fredsun.me/tags/Fragment/"},{"name":"Dialog","slug":"Dialog","permalink":"http://www.fredsun.me/tags/Dialog/"}]},{"title":"Day5 - 单例","slug":"Day5单例","date":"2017-08-14T09:00:00.000Z","updated":"2017-10-20T06:35:29.693Z","comments":true,"path":"2017/08/14/Day5单例/","link":"","permalink":"http://www.fredsun.me/2017/08/14/Day5单例/","excerpt":"饿汉, 懒汉, 双重锁, 枚举, 以及static的正确叫法","text":"饿汉, 懒汉, 双重锁, 枚举, 以及static的正确叫法 保留一段markdown写的toc 关于单例 懒汉式-线程不安全 懒汉式-线程安全 双重检验锁 双重检验锁优化 饿汉式 static final field 静态内部类 static nested class 枚举 总结 PS 参考关于单例 目的: 保证对象的唯一性 核心: 构造方法私有（这一点和 Fragment 要求的构造方法需 public 冲突） 规范 单例只能有一个对象 单例自己在内部创建对象 单例给其他对象提供这个对象 优点 内存中只有一个实例，减少内存开销, 比如频繁的创建和销毁实例 避免对资源的多重应用（比如写文件） 懒汉式-线程不安全 缺点: 当多个线程调用，会创建多个实例12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式-线程安全 优点: 锁方法 缺点: 只有一个线程创建对象，不高效; 锁的效率低，每一次都会开锁12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检验锁 优点: 锁代码块,先判断, 再开锁, 第一个 if 保证了存在则不创建，提高效率 第二个 if 防止多个线程一起进入，创建多个实例 缺点: 1234567891011121314151617181920 1. 给 instance 分配内存 2. 调用 Singleton 的构造函数来初始化成员变量 3. 将 instance 对象指向分配的内存空间* jvm 的即时编译器存在指令重排序的优化, 执行顺序可能是1-2-3或者1-3-2,```javapublic class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; //Single Checked,提高效率 synchronized (Singleton.class) &#123; if (instance == null) &#123; //Double Checked instance = new Singleton(); &#125; &#125; &#125; return instance ; &#125;&#125; 双重检验锁优化 使用了 volatile, 原因是其禁止指令重排序优化, 而不是可见性（保证线程在本地不会存 instance 的副本，每次都是去主内存中读取） 缺点: java5 之前 JMM (Java内存模型)不完善，无法保证 volatile 的屏蔽重排序&#123;.line-numbers&#125;123456789101112131415public class Singleton &#123; private volatile static Singleton instance; //声明成 volatile private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 饿汉式 static final field 缺点:并非懒加载，即加载类一开始就被实例化, 即使客户端没有调用 getInstance() 方法, 如果需要在创建时依赖外部参数，则无法使用1234567public class Singleton&#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; return instance; &#125;&#125; 静态嵌套类 static nested class SingletonHolder 是私有的，外部无法访问，懒汉式 不依赖JDK版本 读取实例时不同步，没性能缺陷123456789public class Singleton&#123; private static class SingletonHolder&#123; private static final Singleton INSTANCE = new instance(); &#125; private Singleton()&#123;&#125;; public static final Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举123public enum EasySingleton&#123; INSTANCE;&#125; 总结 单例有5种, 饿汉式, 懒汉式, 双重检验锁, 静态内部类, 枚举 通常使用饿汉式; 明确懒加载则静态内部类; 反序列化创建对象则使用枚举 ##PS 堆内存放new创建的数组, 对象 栈内存放变量, 数组, 对象的引用(首地址) GC回收的是堆内存的数据,栈内存的引用会在程序运行到代码块作用域外时自动释放 ####参考 如何正确地写出单例模式 菜鸟教程 | 单例模式 java中堆内存和栈内存详解","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.fredsun.me/tags/Java/"},{"name":"静态","slug":"静态","permalink":"http://www.fredsun.me/tags/静态/"},{"name":"static","slug":"static","permalink":"http://www.fredsun.me/tags/static/"}]},{"title":"Day4 - Fragment","slug":"Day4-Fragment","date":"2017-08-10T09:24:00.000Z","updated":"2017-11-09T16:00:00.000Z","comments":true,"path":"2017/08/10/Day4-Fragment/","link":"","permalink":"http://www.fredsun.me/2017/08/10/Day4-Fragment/","excerpt":"Fragment 的使用和生命周期","text":"Fragment 的使用和生命周期 总结 Fragment初始化用newInstance viewPager开多Fragment, 考虑懒加载 getActivity空指针，1* 避免异步中进行```commit() 避免在12345678910111213141516171819202122232425* genymotion别乱拖,否则横竖屏切换不会重启activity* fragment第二次进入显示白[原因](http://blog.csdn.net/u014452224/article/details/45920315?spm=5176.8246799.blogcont.4.nDyPzm)* onBackPressed[BUG](http://blog.csdn.net/zhanhong39/article/details/61261521)* [FragmentStateLoss](https://juejin.im/entry/58636864128fe10069efc4b5)## 生命周期##### 只有在activity处于```onResume()```时，fragment的生命周期才会自由，否则，被activity控制* ```onAttach()```, 拿到activity, [添加Listener](https://stackoverflow.com/questions/32155446/a-method-of-mainactivity-called-from-a-fragment-or-using-a-singleton-class-whic)* ```onCreate（）```, ？？？* ```onCreateView（）```, 创建视图* ```onActivityCreated()```, activity的onCreate 返回时调用* ```onDestroyView()```, Fragment视图被移除时调用* ```onDestroy()```,* ```onDetach()```, Fragment 与 activity 取消关联时调用, 操作与```onAttach()```相反* ![](https://raw.githubusercontent.com/sunxlfred/RES/master/activity_fragment_lifecycle_new.png)## 加载#### 静态加载,类似 view* activity 的布局中 ```xml &lt;fragment android:id=&quot;@+id/id_fragment_title&quot; **必须包含ID** android:name=&quot;com.包名.路径.TitleFragment&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;45dp&quot; /&gt; 动态加载1.构造Google规定 Fragment 需要提供一个 public 的无参构造函数，在 framework 状态恢复时使用 如果需要接受外部的参数创建Fragment的, 需保存参数到 bundle: 123inflate（int resources, 当前布局D ViewGroup root, 根布局G boolean attachToRoot 是否依赖根布局G）, viewgroup的如果设置第三个参数为false, 则当前布局D 不依赖于根布局G, 返回的是xml为根布局的view123456789101112131415161718192021222324252627282930 * 如果不设置attachToRoot的false, * 当fragmentTransaction add 时, **```java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first.```** * 当viewpager导入, 直接报 **OOM*** 这个参数是parentView, 当你创建子布局时, 如果希望这个布局依赖于第二 ```java //FragmentOne中的newInstance函数 public static FragmentOne newInstance(String text)&#123; FragmentOne fragmentOne = new FragmentOne(); Bundle bundle = new Bundle(); bundle.putString(&quot;name&quot;, text);//传参 fragmentOne.setArguments(bundle); return fragmentOne; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); text = getArguments() != null ? getArguments().getString(&quot;name&quot;) : &quot;&quot;; &#125; @Override public void onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; View view = inflater.inflate(R.layout.fragmentm, container, false); return view; &#125; 作者：DrunkPian0 链接：http://www.jianshu.com/p/caa5d6568faa 來源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.替换1234FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();fragmentTransaction.replace(布局，Fragment 实例)fragmentTransaction.commit(); 3. 通信 activity传给fragment activity 中通过Fragment 实例,12345678 也可以* **Fragment传给activity** 1. fragment内部创建接口 ```java public interface FragmentOneBtnClickListener&#123; void onOneBtnClick(); &#125; fragment内按钮点击时调用 123456789Button button = (android.widget.Button) view.findViewById(R.id.btn_frag_one);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (getActivity() instanceof FragmentOneBtnClickListener)&#123; ((FragmentOneBtnClickListener)getActivity()).onOneBtnClick(); &#125; &#125;&#125;); activity实现接口及方法 123456public class MainActivity extends AppCompatActivity implements OneFragment.FragmentOneBtnClickListener&#123; @Override public void onOneBtnClick() &#123; Toast.makeText(this, \"one\", Toast.LENGTH_SHORT).show(); &#125;&#125; Fragment.startActivityForResult();Activity 里的 FragmentOne 调用 开启ActivityTwo, ActivityTwo里的FragmentTwo操作回调时调用```getActivity().setResult(FragmentOne.REQUEST_DETAIL, intent); ```123456789101112131415161718192021222324252627282930##### FragmentManager当activity被杀死重建时,fragment会被保存, 但会创建新的FragmentManager, 新FragmentManager会先去获取保存下来的fragment队列, 再去重建, 从而恢复之前的状态##### FragmentTransaction [(Google)](https://developer.android.com/reference/android/app/FragmentTransaction.html#commitAllowingStateLoss())* ```add()```; 添加 Fragment* ```remove()```; 移除 Fragment, 若添加 ```addToBackStack(null)```，则不会执行 ``onDestroy()`` 和 ```onDetach()```;* ```replace()```; = remove + add* ```hide()```; 隐藏* ```show()```; 显示隐藏的* ```detach(fragment)```; 移除 view, 但 fragment 依然被 FragmentManager 管理* ```attach()```; 重建视图* **```commit();```** 默认异步，并不立刻执行，而是加入 UI 线程的队列中， * 后接executePendingTransactions() 立即执行所有 pending在队列中的transaction* **```commitAllowStateLoss();```*** **```commitNow()^v24^```**, 只同步执行此次 transaction（完善executePendingTransactions），不可与addToBackStack()共用* **```commitNowAllowStateLoss()```**##### Back Stack* Activity 的 BackStack，系统维护，每个 task 一个 BackStack* Fragment 的 BackStack，宿主 Activity 维护，每个 activity 一个* 通过 addToBackStack 调用，按 Back 键后执行 commit 进去的 transaction 的逆操作## v4.fragment 和 app.fragment(以下简称v4和app)1. 支持版本不同, v4支持到4, app只支持11及以上2. v4需要jar包3. 获取 FragmentManager * v4: ```getSupportFragmentManager app: 12344. 包含 v4 的 Activity 需要继承 FragmentActivity5. v4的不支持 objectAnimator, Animator, 即不支持属性动画，只支持位移动画。[参考](http://www.jianshu.com/p/1d2a3d5229fd)6. mStateSaved 何时置为true * v4在 ```onSaveInstanceState``` 和 ```onStop app在 1234567891011121314151617181920212223242526272829303132333435##### 举例###### 例1 commitAllowStateLoss1. acticity 中放入 FragmentA;2. activity 被后台，运行 ```onStop``` 和 ```onSaveInstanceState```;3. 某个事件触发下，FragmentB replace FragmentA,提交的是 **```commitAllowStateLoss```**;4. 此时可能会发生两种情况 * 第一种，系统杀死了activity，activity重建，使用步骤2的onSaveInstanceState恢复，A恢复，B没有 * 第二种，activity 没被杀死，FragmentB 显示，到下次 Activity stop时，这个包含了 B 的状态被保存了下来###### 例2 fragment中执行异步1. activity 执行AsyncTask, 同时打开 ~~ProgressDialog~~ ([API26被弃用,推荐ProgressBar和Notification](https://developer.android.com/reference/android/app/ProgressDialog.html))2. 执行过程中, 进行旋转屏幕 可能的情况如下: * 上个线程还在执行, 又开一个线程, 可能操作一些已经被处理的控件, 报空 * 关闭dialog的代码在onPostExecute, 但是上个线程被杀死, 无法关闭* 解决: DialogFragment ###### 例3 内存泄漏 [from简书](http://www.jianshu.com/p/caa5d6568faa)1. util.class ```java public class Util &#123; private Context mContext; private static Util sInstance; private Util(Context context) &#123; this.mContext = context; &#125; public static Util getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new Util(context); &#125; return sInstance; &#125; //other methods &#125; Fragment用了上面的类 Fragment被干掉, GC想回收Fragment占用的内存, 但因为sInstance 是静态的, 一直持有fragment的引用, 即使12* 解决: 1. 用 ```getApplicationContext() 弱引用 把sInstance用WeakReference包起来, 需要的时候1234567891011121314151617181920212223###### 例4 横竖屏切换[fromHongYang](http://blog.csdn.net/lmj623565791/article/details/37992017)* 横竖屏切换时, activity重建, fragment生命周期跟着变, 同时因为activity的```onSaveInstanceState```, 之前的fragment们也被还原出来，会产生多个fragment* **第一次切换** * ![](https://raw.githubusercontent.com/sunxlfred/RES/master/fragment%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%AC%AC%E4%B8%80%E6%AC%A1.png)* **第二次切换** * ![](https://github.com/sunxlfred/RES/raw/master/fragment%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E4%B8%A4%E6%AC%A1.png)* 按下Home键后的生命周期 * ![](https://raw.githubusercontent.com/sunxlfred/RES/master/WhenOnSaveInstanceState.png)* 解决: activity 的 ```onCreate```方法中添加bundle非空后再进行```transaction```和 ```commit```, ```java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... if (savedInstanceState == null) &#123; FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.add(R.id.layout, oneFragment, &quot;one&quot;); fragmentTransaction.commit(); &#125; ... &#125; Fragment+ActionBar(ToolBar)Fragment自己实现 Fragment 的 xml 里添加 toolBar onCreate加入 setHasOptionsMenu(true) 12345@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setHasOptionsMenu(true);&#125; 设置依赖的activity.setSupportActionBar 12345678@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_one, container, false); Toolbar toolbar = (Toolbar) view.findViewById(R.id.fragment_toolbar); mActivity.setSupportActionBar(toolbar); return view;&#125; 实现onCreateOptionsMenu 12345@Overridepublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.toolbar, menu);&#125; 点击事件onOptionsItemSelected 123456789@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.id_menu_fra_test: Toast.makeText(getActivity(), \"FragmentMenuItem1\", Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125; Activity实现PS: Activity自身ToolBar manifest 把 theme 的 parent 改成 NoActionBar activity布局里添加ToolBar activity的onCreate方法setSupportActionBar(); 12Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar); activity 重写 onCreateOptionsMenu 添加布局 12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar, menu); return true;&#125; 重写 onOptionsItemSelected 添加点击事件 1234567891011121314151617@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId())&#123; case R.id.backup: Toast.makeText(this, \"backup\", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, \"del\", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, \"set\", Toast.LENGTH_SHORT).show(); break; &#125; return true;&#125; FragmentPagerAdapter 和 FragmentStatePagerAdapter FragmentPagerAdapter: 调用depatch(), 只销毁视图, 适合主界面 FragmentPagerAdapter: 销毁, 可存数据进bundle, 然后保存在onSaveInstanceState DialogFragment 替代 Dialog和AlertDialogDialog和继承的AlertDialog无法在横竖屏切换时保存数据, DialogFragment依靠FragmentManager自动重建并恢复数据 自定义view 的 DialogFragment 创建 12345678910public class EditDialogFragment extends DialogFragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.fragment_dialog, container); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); return inflate; &#125; &#125; AlertDialog 的 DialogFragment 创建 12345678910111213141516 AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); LayoutInflater layoutInflater = getActivity().getLayoutInflater(); View view = layoutInflater.inflate(R.layout.fragment_dialog, null);// editName = (EditText) view.findViewById(R.id.id_txt_your_name); builder.setView(view) .setNegativeButton(\"sign\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getContext(),\"test\",Toast.LENGTH_SHORT).show();// LoginCompleteListener loginCompleteListener = (LoginCompleteListener) getActivity();// loginCompleteListener.onLoginComplete(editName.getText().toString(), \"123\"); &#125; &#125;).setPositiveButton(\"Cancel\", null); return builder.create(); Fragment来保存数据系统帮助数据恢复 少量数据 和 ```onRestoreInstanceState```123456789101112131415161718192021222324* 大量数据, 无法序列化, 如bitmap, 用Fragment存放, 但是切勿传递任何包含context的对象 1. 创建Fragment, **添加 ```setRetainInstance```** ```java public class RetainedFragment extends Fragment &#123; // data object we want to retain private MyDataObject data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); &#125; public void setData(MyDataObject data) &#123; this.data = data; &#125; public MyDataObject getData() &#123; return data; &#125; &#125; activity调用fragment保存123456789101112131415161718192021222324252627282930313233public class MyActivity extends Activity &#123; private RetainedFragment dataFragment; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); // find the retained fragment on activity restarts FragmentManager fm = getFragmentManager(); dataFragment = (DataFragment) fm.findFragmentByTag(“data”); // create the fragment and data the first time if (dataFragment == null) &#123; // add the fragment dataFragment = new DataFragment(); fm.beginTransaction().add(dataFragment, “data”).commit(); // load the data from the web dataFragment.setData(loadMyData()); &#125; // the data is available in dataFragment.getData() ... &#125; @Override public void onDestroy() &#123; super.onDestroy(); // store the data in the fragment dataFragment.setData(collectMyLoadedData()); &#125;&#125; 自行处理数据变更（activity不重走生命周期, 不推荐) 在manifest的\\里添加属性 123&lt;activity android:name=\".MyActivity\" android:configChanges=\"orientation|keyboardHidden\" android:label=\"@string/app_name\"&gt; 屏幕切换时可通过123456789101112```java@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); // Checks the orientation of the screen if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)&#123; Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 进阶-Fragment保存AsyncTaskactivity在 和 ```onSaveInstanceState``` 回调AsyncTask, 并在onCreate时调用 setData1234567891011121314151617181920212223242526272829301. 创建Fragment, 不过setData保存的是AsyncTask```javapublic class OtherRetainedFragment extends Fragment&#123; // data object we want to retain // 保存一个异步的任务 private MyAsyncTask data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); &#125; public void setData(MyAsyncTask data) &#123; this.data = data; &#125; public MyAsyncTask getData() &#123; return data; &#125;&#125; 创建AsyncTask 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; private FixProblemsActivity activity; /** * 是否完成 */ private boolean isCompleted; /** * 进度框 */ private LoadingDialog mLoadingDialog; private List&lt;String&gt; items; public MyAsyncTask(FixProblemsActivity activity) &#123; this.activity = activity; &#125; /** * 开始时，显示加载框 */ @Override protected void onPreExecute() &#123; mLoadingDialog = new LoadingDialog(); mLoadingDialog.show(activity.getFragmentManager(), \"LOADING\"); &#125; /** * 加载数据 */ @Override protected Void doInBackground(Void... params) &#123; items = loadingData(); return null; &#125; /** * 加载完成回调当前的Activity */ @Override protected void onPostExecute(Void unused) &#123; isCompleted = true; notifyActivityTaskCompleted(); if (mLoadingDialog != null) mLoadingDialog.dismiss(); &#125; public List&lt;String&gt; getItems() &#123; return items; &#125; private List&lt;String&gt; loadingData() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; return new ArrayList&lt;String&gt;(Arrays.asList(\"通过Fragment保存大量数据\", \"onSaveInstanceState保存数据\", \"getLastNonConfigurationInstance已经被弃用\", \"RabbitMQ\", \"Hadoop\", \"Spark\")); &#125; /** * 设置Activity，因为Activity会一直变化 * * @param activity */ public void setActivity(FixProblemsActivity activity) &#123; // 如果上一个Activity销毁，将与上一个Activity绑定的DialogFragment销毁 if (activity == null) &#123; mLoadingDialog.dismiss(); &#125; // 设置为当前的Activity this.activity = activity; // 开启一个与当前Activity绑定的等待框 if (activity != null &amp;&amp; !isCompleted) &#123; mLoadingDialog = new LoadingDialog(); mLoadingDialog.show(activity.getFragmentManager(), \"LOADING\"); &#125; // 如果完成，通知Activity if (isCompleted) &#123; notifyActivityTaskCompleted(); &#125; &#125; private void notifyActivityTaskCompleted() &#123; if (null != activity) &#123; activity.onTaskCompleted(); &#125; &#125;&#125; 创建activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class FixProblemsActivity extends ListActivity &#123; private static final String TAG = \"MainActivity\"; private ListAdapter mAdapter; private List&lt;String&gt; mDatas; private OtherRetainedFragment dataFragment; private MyAsyncTask mMyTask; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.e(TAG, \"onCreate\"); // find the retained fragment on activity restarts FragmentManager fm = getFragmentManager(); dataFragment = (OtherRetainedFragment) fm.findFragmentByTag(\"data\"); // create the fragment and data the first time if (dataFragment == null) &#123; // add the fragment dataFragment = new OtherRetainedFragment(); fm.beginTransaction().add(dataFragment, \"data\").commit(); &#125; mMyTask = dataFragment.getData(); if (mMyTask != null) &#123; mMyTask.setActivity(this); &#125; else &#123; mMyTask = new MyAsyncTask(this); dataFragment.setData(mMyTask); mMyTask.execute(); &#125; // the data is available in dataFragment.getData() &#125; @Override protected void onRestoreInstanceState(Bundle state) &#123; super.onRestoreInstanceState(state); Log.e(TAG, \"onRestoreInstanceState\"); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; mMyTask.setActivity(null); super.onSaveInstanceState(outState); Log.e(TAG, \"onSaveInstanceState\"); &#125; @Override protected void onDestroy() &#123; Log.e(TAG, \"onDestroy\"); super.onDestroy(); &#125; /** * 回调 */ public void onTaskCompleted() &#123; mDatas = mMyTask.getItems(); mAdapter = new ArrayAdapter&lt;String&gt;(FixProblemsActivity.this, android.R.layout.simple_list_item_1, mDatas); setListAdapter(mAdapter); &#125;&#125; BUGS findFragmentByTag 查不到 解决: 在 onCreate() 里提交commit()后, 在 onStart() 里find, 不能直接在commit()之后 嵌套WTFs/min = 2^fragment countfindViewByTag findViewById 是xml用了Fragment的查找方法, 如果我们是 findViewByTag 可以通过三种方式获取到Fragment* 官方推荐, 在没有使用ViewPager的前提下 - 在创建时添加.摸我 如果上了viewpager. 根据源码里查询 Fragment 的方法自己拼接 Link1Fragment f = fragmentManager.findFragmentByTag(&quot;android:switcher:&quot; + R.id.mViewpager+ &quot;:&quot;+ mViewPager.getCurrentItem()); 参考 简书 | EP38-Fragment单例和内存泄露 简书 | Android Fragment使用(一) 基础篇 温故知新 CSDN | android.support.v4.app.Fragment和 android.app.Fragment的区别 CSDN | Android Fragment 真正的完全解析（上） CSDN | Android Fragment 真正的完全解析（下） CSDN | Android Fragment 你应该知道的一切 CSDN | Android 官方推荐 : DialogFragment 创建对话框 Google | 处理运行时变更 CSDN | Android 屏幕旋转 处理 AsyncTask 和 ProgressDialog 的最佳方案 CSDN | android fragment事务的提交使用的时候出现的一些问题。。 简书 | Fragment进阶-commit使用细节及源码分析 建议阅读 Android Fragment 的使用，一些你不可不知的注意事项","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://www.fredsun.me/tags/Fragment/"}]},{"title":"Day3 - 7层/4层网络协议","slug":"Day3-7层4层网络协议","date":"2017-08-09T15:42:00.000Z","updated":"2017-10-20T06:14:55.423Z","comments":true,"path":"2017/08/09/Day3-7层4层网络协议/","link":"","permalink":"http://www.fredsun.me/2017/08/09/Day3-7层4层网络协议/","excerpt":"现在已经都说四层网络结构了","text":"现在已经都说四层网络结构了 学会了 复习七层网络结构，在 tcp 协议族中，又合并拆分成四层， 主机 应用层, HTTP 协议, HTTPS/FTP/POP3/SMTP/Telnet/DNS包含了原表示层和会话层 传输层, TCP协议, UDP 网络层, IPV4／IPV6, ICMP, OSPF, EIGRP, IGMP 数据链路层, SLIP, CSLIP, PPP, MTU","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"web","slug":"web","permalink":"http://www.fredsun.me/tags/web/"}]},{"title":"Day2 - 导入外部数据库","slug":"Day2-导入外部数据库","date":"2017-08-06T16:00:00.000Z","updated":"2017-10-18T16:00:00.000Z","comments":true,"path":"2017/08/07/Day2-导入外部数据库/","link":"","permalink":"http://www.fredsun.me/2017/08/07/Day2-导入外部数据库/","excerpt":"adb 查看数据库","text":"adb 查看数据库 Day2学会了 打开 assets 中的数据库不需要权限,属于内部存储 open failed: EACCES (Permission denied) 除了 android 运行时权限外，还可能是文件名不对或者模拟器的 data/data/包名/databases 目录没有打开权限，通过 adb shell ，运行 su, 再 chmod 777 包名,将’drwxrwxrwx’9位都设置成1的权限即可，即 111 111 111, 7 7 7.参考 当磁盘写满时，getReadableDatabase() 返回的对象将以只读的方式打开数据库，而getWriteableDatabase() 则会异常 Android 导入db数据流程：db文件放到assets -&gt; 读db，流转到databases文件夹下 -&gt; sqliteOpenHelper操作adb查看数据库 adb shell cd data/data/包名/databases ls 查看 sqlite3 库名.db .table 查看表 .chema查看比建表语句 .exit或.quit退出编辑 如果出现无法退出 …&gt; 模式，则输入.exit;即完成语句加分号 exit退出","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"sqlite","slug":"sqlite","permalink":"http://www.fredsun.me/tags/sqlite/"}]},{"title":"Day1 - sqlite","slug":"Day1-sqlite","date":"2017-08-03T15:42:00.000Z","updated":"2017-10-20T06:32:16.617Z","comments":true,"path":"2017/08/03/Day1-sqlite/","link":"","permalink":"http://www.fredsun.me/2017/08/03/Day1-sqlite/","excerpt":"sqlite不能添加主键，只能新建表再复制, 整理了《第一行代码》的和风天气接口","text":"sqlite不能添加主键，只能新建表再复制, 整理了《第一行代码》的和风天气接口 总结 sqlite 的建表，增删改查 sqlite不能添加主键，删除列，alert命令被阉割后只能修改表名，新建列，而添加主键需按照格式创建新表，复制旧表过去sqlite11 表的复制失败，可能因为之前的表没有主键，导致数据重复，无法复制到以重复列做主键的新表 数据库命名，小写或_ ，尽量不大写，linux区分大小写，windows不区分 复习了 IO流 idea注册码和webstorm一样，License server 输入 http://idea.iteblog.com/key.php 判null string.replace方法需返回给自己才能生效 line = line.replace(…); 制作天气功能数据源 郭霖 的《第一行代码》里给的自建接口似乎因为和风天气接口升级而挂了，一时没法筛选城市，便根据hongyang自建接口的和风天气源提取城市列表，而网站给出的是txt格式，前公司的城市列表存的是json格式，再综合考虑一下内存问题(也就省了几kb吧。。不如处理图片内存去了。。)后，考虑使用数据库来存储。 流程概括是.txt -&gt; CSVToJSON -&gt;.sqlite 步骤 将和风天气源文档复制 粘贴到http://www.convertcsv.com/csv-to-json.htm,STEP5获取到CSV To Keyed JSON，另存为本地txt 通过自己的代码将txt转为db SQL语句","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"sqlite","slug":"sqlite","permalink":"http://www.fredsun.me/tags/sqlite/"}]},{"title":"Day0 - Android","slug":"Day0-Android","date":"2017-08-01T04:31:00.000Z","updated":"2017-10-29T16:00:00.000Z","comments":true,"path":"2017/08/01/Day0-Android/","link":"","permalink":"http://www.fredsun.me/2017/08/01/Day0-Android/","excerpt":"版本号/HAL层/UML/抽象/内部类/闭包/AndroidStudioBug","text":"版本号/HAL层/UML/抽象/内部类/闭包/AndroidStudioBug 版本号latest 10/30/2017 from Version Codename API Distribution 2.3.3 - 2.3.7 Gingerbread 10 0.3% 4.0.3 - 4.0.4 Ice Cream Sandwich 15 0.3% 4.1.x Jelly Bean 16 2.3% 4.2.x - 17 3.3% 4.3 - 18 1.0% 4.4 KitKat 19 14.5% 5.0 Lollipop 21 6.7% 5.1 22 21.0% 6.0 Marshmallow 23 32.0% 7.0 Nougat 24 15.8% 7.1 25 2.0% 8.0 Oreo 26 0.2% 8.1 27 - 谷歌不推荐的版本 1.6 Donut 2.2 Froyo 8 - 获取版本号12345678910111213/** * 获取Android发布的版本 */ public static String getVersion() &#123; return android.os.Build.VERSION.RELEASE; &#125; /** * 获取SDK的API Level * @return */ public static int getSDK() &#123; return android.os.Build.VERSION.SDK_INT; &#125; 版本号适配TODO http://blog.csdn.net/haovip123/article/details/54618642 Android 几层 原 4 层 现 5 层 HAL层:谷歌把 Linux 内核空间分成了 User Space 和 Kernal Space. HAL层运行在 UserSpace. Linux 内核运行在Kernal Space. Android 源代码遵循 Apache License, Linux内核源代码遵循 GNU License. GNULicense 需要在发布时发布源代码. 谷歌为了保护制造商的信息, 把硬件信息等放进了HAL.所以android是开放, 并不属于Linux的分支, 因为没了HAL层的驱动对硬件层的支持不完整, 不是可移植系统. 5.1的 NestedScrollingParent(外部监听滑动事件)6.0的权限12345protected boolean hasPermission(String permission) &#123; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP_MR1) return (checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED); return true; &#125; 通知的副标题 API LEVEL16才能使用123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; builder.setSubText(&quot;it is really basic&quot;);&#125; 7.0 分屏多任务将 DecorView 从 PhoneWindow 中移出来, 并添加了 DecorCaptionView 作为分屏的实现 API Level建议写成版本名VERSION_CODES, 少用数字 7.0 api-24.2.0 拆v4库, MotioneventCompat 被 Motionevent 替换 以下类中的几种方法只需要API 8及更低版本，不再需要使用。而是使用框架实现。android.support.v4.view.KeyEventCompat： 用。。。来代替 KeyEventandroid.support.v4.view.MotionEventCompat： 使用 MotionEventandroid.support.v4.view.ViewCompat： 使用 Viewandroid.support.v4.view.ViewConfigurationCompat： 使用 ViewConfiguration UML图泛化(generalization)= is-a, 继承 实现(realize)= like-a, 实现 依赖(dependency)= 方法的形参, 局部变量, 对静态方法的调用 关联(association)= 成员变量 聚合(aggregation)= has-a, 不是强依赖, 如果整体不存在了, 个体还是存在的 组合(composition)= contains-a, 强依赖, 如果整体不存在了, 部分也不存在了 聚合和组合是关联关系的一种特例组合 &gt; 聚合 &gt; 关联 &gt; 依赖; 抽象类和接口抽象类是对根源的抽象, 接口是对动作的抽象抽象类是像xxx一样, 接口是能xxx这样抽象类可以有非抽象方法, 接口不行抽象类可以没有抽象方法, 接口不行抽象类可以有参数, 接口不行 内部类内部类只是 Java 的语法糖之一（在编译期做手脚）, 过了编译期后, 变生成两个 Java 文件内部类会持有外部类的引用匿名内部类是唯一没有构造器的类, 一般用于实现抽象类/接口 闭包From对象是带方法的数据, 而闭包是带(外部)数据的方法条件如下： 一个依赖于外部自由变量的函数 这个函数能够访问外围环境里的自由变量 关于组合子:内部操作依赖的变量全部由参数提供了的 “自给自足” 的函数f(x,y) = x+y 123public int add(int x, int y)&#123; return x+y;&#125; 关于自由变量: 在函数作用域以外，由函数的外部环境提供的参数就叫”自由变量（Free Variable）”f(x)=x+y 12345int y=3;add()&#123; int x=2; return x+y;&#125; 闭包: 就是把函数以及变量包起来，使得变量的生存周期延长。闭包跟面向对象是一棵树上的两条枝，实现的功能是等价的。所以java的类其实也是闭包 内部类是闭包(包含外部类的引用)如果局部内部类直接使用外部类的局部变量, 在Java多线程等情况下, 可能会产生外部类已被回收, 但是内部类还在运行, 那么内部类就可能会去访问一个不存在的外部类的局部变量.那么当局部变量被置为 final 时, 编译器会将 final 局部变量复制一份, 复制品直接作为局部内部中的数据成员, 这样, 当局部内部类访问变量时, 其实访问的是复制品. Java编译器实现的只是capture-by-value(包括lambda表达式)，并没有实现capture-by-reference 而且由于被 final 修饰的变量赋值后不能再修改, 所以就保证了复制品与原始变量的一致, 给人的感觉：好像局部变量的生命期延长了.这也是 Java的闭包. AndroidStudio 代码提示快捷键ClassNameCompletion win &amp; mac: Control + Shift + 空格键 和系统冲突, 建议keymap里修改. Gradle卡住 gradle/wrapper/gradle-wrapper.properties 里的 distributionUrl 改成目前项目已有的, 再导入 Logo xxxhdpi 192x192 xxhdpi 144x144 xhdpi 96x96 hdpi 72x72 mdpi 48x48 参考Google | 信息中心简书 | Android-SDK版本号表格CSDN | 重新认识java（四） — 组合、聚合与继承的爱恨情仇CSDN | 看懂UML类图和时序图cnblogs | UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","categories":[{"name":"100DaysOfAndroid","slug":"100DaysOfAndroid","permalink":"http://www.fredsun.me/categories/100DaysOfAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.fredsun.me/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.fredsun.me/tags/Java/"}]}]}